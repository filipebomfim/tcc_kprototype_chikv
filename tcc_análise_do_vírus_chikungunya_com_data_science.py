# -*- coding: utf-8 -*-
"""[FINAL] TCC Análise do vírus Chikungunya com Data Science.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Zo6KNg_dp4JWMHOROv5mZVIW6k97fo-O

![logo.png](data:image/png;base64,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)

**Universidade do Estado da Bahia**

**Filipe Bomfim Santos Furtado**

**Trabalho de Conclusão de Curso**

*Análise de dados de Epidemiologia Molecular do vírus chikungunya utilizando o algoritmo K-prototype*

# **Importação das Bibliotecas Necessárias**

---
"""

!pip install kmodes
!pip install KPrototypes
!pip install dython
!pip install shap

import pandas as pd
import numpy as np 
import plotly.express as px
import seaborn as sns
import matplotlib.pyplot as plt
from matplotlib.ticker import StrMethodFormatter

from plotnine import *
import plotnine

from kmodes.kmodes import KModes
from kmodes.kprototypes import KPrototypes

from sklearn.metrics import jaccard_score, f1_score
from sklearn.metrics.cluster import adjusted_rand_score

plt.style.use("fivethirtyeight")


from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.linear_model import LogisticRegression
from sklearn.tree import DecisionTreeClassifier
from sklearn.metrics import confusion_matrix
from plotly import graph_objects as go

from scipy.stats import chi2_contingency
from scipy.stats import chi2
from tqdm import tqdm
from dython.model_utils import roc_graph
from dython.nominal import associations

from lightgbm import LGBMClassifier
import shap
from sklearn.model_selection import cross_val_score

import warnings
warnings.filterwarnings("ignore")

#import warnings 
#warnings.filterwarnings ('ignore', category = FutureWarning)

"""# **[1] --- PRÉ-PROCESSAMENTO DE DADOS**

# **Funções para limpeza dos dados socioeconômicos**

---

**Função para remoção das colunas que não fazem parte do escopo do projeto**
"""

def selecionarColunas(dataframe):
  lista = []
  for column in dataframe:
    if(type(column)==str):
      if column != "Country":
        lista.append(column)
  
  return lista

#dataframeT.loc[linha,"Value"]= round(dataframe.loc[linha_aux,columns[i]],3)

"""#**Limpeza dos Dados do ABVdb**

---

**Importação do arquivo Excel**
"""

df_chikv=pd.read_excel('/content/CHIKV.xls')
df_chikv

"""**Remoção das colunas e linhas que não fazem parte do escopo do projeto**"""

df_chikv.drop(columns=['Virus','Product','Size','Clinic'], inplace=True)
df_chikv

"""# **Limpeza dos Dados referente ao IDH**

---

**Importação do arquivo CSV, com valores separados por ponto e vírgula**
"""

df_idh=pd.read_excel('/content/HDI.xls')
df_idh

"""**Removendo as colunas vazias do dataframe de IDH**"""

df_idh.drop(columns=selecionarColunas(df_idh), inplace=True)
df_idh

"""**Transformar colunas em linhas**"""

df_idh = pd.melt(df_idh.reset_index(),id_vars=['Country'],var_name='Date',
                 value_name='IDH',ignore_index=True).sort_values(['Country'],ascending=True)

df_idh.drop(df_idh[(df_idh['Date'] == 'index')].index,inplace=True)
df_idh = df_idh.sort_values(['Country','Date'],ascending=True)
df_idh = df_idh.reset_index(drop=True)
df_idh

print (type(df_idh.loc[200,"IDH"]))

display(df_idh.loc[985])

"""**Exportação da versão transposta do Dataframe IDH**"""

df_idh.to_csv(r'/content/idh_data_final.csv', index = False)

"""# **Limpeza dos Dados referente ao BS**

---

**Importação do arquivo CSV, com valores separados por ponto e vírgula**
"""

df_bs=pd.read_excel('/content/BS.xls')
df_bs

"""**Removendo as colunas vazias do dataframe de IDH**"""

df_bs.drop(columns=selecionarColunas(df_bs), inplace=True)
df_bs

"""**Transformar colunas em linhas**"""

df_bs = pd.melt(df_bs.reset_index(),id_vars=['Country'],var_name='Date',
                 value_name='ASB',ignore_index=True).sort_values(['Country'],ascending=True)

df_bs.drop(df_bs[(df_bs['Date'] == 'index')].index,inplace=True)
df_bs = df_bs.sort_values(['Country','Date'],ascending=True)
df_bs = df_bs.reset_index(drop=True)
df_bs

print (type(df_bs.loc[200,"ASB"]))

display(df_bs.loc[985])

"""**Exportação da versão transposta do Dataframe IDH**"""

df_bs.to_csv(r'/content/asb_data_final.csv', index = False)

"""# **Limpeza dos Dados referente ao GSPIB**

---

**Importação do arquivo CSV, com valores separados por ponto e vírgula**
"""

df_gspib=pd.read_excel('/content/GSPIB.xls')
df_gspib

"""**Removendo as colunas vazias do dataframe de IDH**"""

df_gspib.drop(columns=selecionarColunas(df_gspib), inplace=True)
df_gspib

"""**Transformar colunas em linhas**"""

df_gspib = pd.melt(df_gspib.reset_index(),id_vars=['Country'],var_name='Date',
                 value_name='GSPIB',ignore_index=True).sort_values(['Country'],ascending=True)

df_gspib.drop(df_gspib[(df_gspib['Date'] == 'index')].index,inplace=True)
df_gspib = df_gspib.sort_values(['Country','Date'],ascending=True)
df_gspib = df_gspib.reset_index(drop=True)
df_gspib

print (type(df_gspib.loc[200,"GSPIB"]))

display(df_gspib.loc[985])

"""**Exportação da versão transposta do Dataframe IDH**"""

df_gspib.to_csv(r'/content/gspib_data_final.csv', index = False)

"""# **[2] --- ANÁLISE EXPLORATÓRIA**

# **Análise Exploratória - df_chikv**


---

**Análise do dataframe df_chikv**
"""

display(df_chikv['Genotype'].value_counts())

x = ['East-Central-South-African','Asian and Caribbean', 'Could not assign','West African']
y = [2215,865,131,21]

ax = plt.subplots(figsize=(8, 5))
plt.barh(x,y,height=0.5,edgecolor='w')
plt.ylabel("Genótipos", fontweight='bold')
plt.xlabel("Frequências", fontweight='bold')
plt.rcParams.update({'font.size': 14})
plt.style.use("fivethirtyeight")
plt.xticks(np.arange(0, 2700, step=300))


for index, value in enumerate(y):
    plt.text(value+35, index+0.05, str(value), color='black', fontweight='bold',fontsize=12)

plt.show()

display(df_chikv['Gender'].value_counts())

x = ['Masculino','Feminino', 'unknown', 'Sem Registro']
y = [141,119,4, 2968]

ax = plt.subplots(figsize=(8, 5))
plt.barh(x,y,height=0.5,edgecolor='w')
plt.ylabel("Gênero", fontweight='bold')
plt.xlabel("Frequências", fontweight='bold')
plt.rcParams.update({'font.size': 14})
plt.style.use("fivethirtyeight")
plt.xticks(np.arange(0, 2700, step=300))


for index, value in enumerate(y):
    plt.text(value+35, index+0.05, str(value), color='black', fontweight='bold',fontsize=12)

plt.show()

display(df_chikv.info())

df_chikv.isnull().sum()

"""Após a análise pode-se notar que: 


1.   Na coluna "Genótipos", existem outliers chamados "Could not assign" que não fazem parte do escopo do projeto e precisam ser excluídos;

**Exclusão dos outliers de df_chikv**
"""

outliers = df_chikv[(df_chikv['Genotype']=="Could not assign")
                    | (df_chikv['Gender']=="unknown")].index
df_chikv.drop(outliers,inplace=True)
df_chikv = df_chikv.reset_index(drop=True)

df_chikv

"""**Resultados**"""

fig = px.histogram(df_chikv, x="Genotype", color="Genotype")
fig.show()

fig = px.histogram(df_chikv, x="Date", color="Genotype")
fig.show()

display(df_chikv.info())

display(df_chikv['Genotype'].value_counts())

"""# **Análise Exploratória - df_idh**


---

**Análise do dataframe df_idh**
"""

bins=[0, 0.1, 0.2, 0.3, 0.4, 0.5,0.6,0.7,0.8,0.9,1]
ax = plt.subplots(figsize=(10, 6))
counts, bins, _ = plt.hist(df_idh['IDH'], bins=bins,edgecolor='w')
plt.ylabel("Frequências",fontweight="bold")
plt.xlabel("IDH",fontweight="bold")
plt.rcParams.update({'font.size': 15})
plt.style.use("fivethirtyeight")
plt.yticks(np.arange(0, 1600, step=160))
plt.xticks(np.arange(0, 1.1, step=0.1))

for n, b in zip(counts, bins):
        n = int(n)
        plt.gca().text(b+0.03, n + 35, str(n), color='black',fontweight="bold",fontsize=12)


plt.show()

display(df_idh.info())

display(df_idh['Date'].value_counts().sort_index())

display(df_idh['IDH'].value_counts().sort_index())

"""Após a análise pode-se notar que: 


1.   Na coluna "IDH", existem outliers chamados de valores zerados, que precisam ser removidos;
2.   Na coluna "Date", existem anos que não fazem parte do escopo entre 2004 e 2017 e também precisam ser excluídos.

**Exclusão dos outliers de df_chikv**
"""

outliers = df_idh[(df_idh['IDH'] == 0)
     | (df_idh['Date'] < 2004) | (df_idh['Date']>2017)].index
df_idh.drop(outliers,inplace=True)
df_idh = df_idh.reset_index(drop=True)

bins=[0, 0.1, 0.2, 0.3, 0.4, 0.5,0.6,0.7,0.8,0.9,1]
ax = plt.subplots(figsize=(10, 6))
counts, bins, _ = plt.hist(df_idh['IDH'], bins=bins,edgecolor='w')
plt.ylabel("Frequências", fontweight='bold')
plt.xlabel("IDH", fontweight='bold')
plt.rcParams.update({'font.size': 15})
plt.style.use("fivethirtyeight")
plt.yticks(np.arange(0, 1600, step=160))
plt.xticks(np.arange(0, 1.1, step=0.1))

for n, b in zip(counts, bins):
        n = int(n)
        plt.gca().text(b+0.03, n + 35, str(n), color='black', fontweight='bold',fontsize=12)


plt.show()

"""**Resultados**"""

display(df_idh.info())

display(df_idh['Date'].value_counts().sort_index())

display(df_idh['IDH'].value_counts().sort_index())

df_idh

"""# **Análise Exploratória - df_bs**


---

**Análise do dataframe df_bs**
"""

bins=[0, 10, 20, 30, 40, 50,60,70,80,90, 100]
ax = plt.subplots(figsize=(10, 6))
counts, bins, _ = plt.hist(df_bs['ASB'], bins=bins,edgecolor='w')
plt.ylabel("Frequências", fontweight='bold')
plt.xlabel("Porcentagem da população com acesso a saneamento básico", fontweight='bold')
plt.rcParams.update({'font.size': 15})
plt.style.use("fivethirtyeight")
plt.yticks(np.arange(0, 1600, step=150))
plt.xticks(np.arange(0, 100, step=10))
for n, b in zip(counts, bins):
        n = int(n)
        plt.gca().text(b+3, n + 35, str(n), color='black', fontweight='bold',fontsize=12)


plt.show()

display(df_bs.info())

display(df_bs['Date'].value_counts().sort_index())

display(df_bs['ASB'].value_counts().sort_index())

"""Após a análise pode-se notar que: 


1.   Na coluna "Value", existem outliers chamados de valores zerados, que precisam ser removidos;
2.   Na coluna "Date", existem anos que não fazem parte do escopo entre 2004 e 2017 e também precisam ser excluídos.

**Exclusão dos outliers de df_chikv**
"""

outliers = df_bs[(df_bs['ASB'] == 0)
     | (df_bs['Date'] < 2004) | (df_bs['Date']>2017)].index
df_bs.drop(outliers,inplace=True)
df_bs = df_bs.reset_index(drop=True)

"""**Resultados**"""

bins=[0, 10, 20, 30, 40, 50,60,70,80,90, 100]
ax = plt.subplots(figsize=(10, 6))
counts, bins, _ = plt.hist(df_bs['ASB'], bins=bins,edgecolor='w')
plt.ylabel("Frequências", fontweight='bold')
plt.xlabel("Porcentagem da população com acesso a saneamento básico", fontweight='bold')
plt.rcParams.update({'font.size': 15})
plt.style.use("fivethirtyeight")
plt.yticks(np.arange(0, 1600, step=150))
plt.xticks(np.arange(0, 100, step=10))
for n, b in zip(counts, bins):
        n = int(n)
        plt.gca().text(b+3, n + 35, str(n), color='black', fontweight='bold',fontsize=12)


plt.show()

display(df_bs.info())

display(df_bs['Date'].value_counts().sort_index())

display(df_bs['ASB'].value_counts().sort_index())

df_bs

"""# **Análise Exploratória - df_gspib**


---

**Análise do dataframe df_chikv**
"""

bins=[0, 5, 10, 15, 20, 25,30,35,40,45,50]
ax = plt.subplots(figsize=(10, 6))
counts, bins, _ = plt.hist(df_gspib['GSPIB'], bins=bins,edgecolor='w')
plt.ylabel("Frequências", fontweight='bold')
plt.xlabel("Porcentagem do PIB gasto com saúde", fontweight='bold')
plt.rcParams.update({'font.size': 15})
plt.style.use("fivethirtyeight")
plt.yticks(np.arange(0, 1650, step=160))
plt.xticks(np.arange(0, 55, step=5))
for n, b in zip(counts, bins):
        n = int(n)
        plt.gca().text(b+1.1, n + 35, str(n), color='black', fontweight='bold',fontsize=12)


plt.show()

display(df_gspib.info())

display(df_gspib['Date'].value_counts().sort_index())

display(df_gspib['GSPIB'].value_counts().sort_index())

"""Após a análise pode-se notar que: 


1.   Na coluna "Value", existem outliers chamados de valores zerados, que precisam ser removidos.

**Exclusão dos outliers de df_chikv**
"""

outliers = df_gspib[(df_gspib['GSPIB'] == 0)].index
df_gspib.drop(outliers,inplace=True)
df_gspib = df_gspib.reset_index(drop=True)

"""**Resultados**"""

bins=[0, 5, 10, 15, 20, 25,30,35,40,45,50]
ax = plt.subplots(figsize=(10, 6))
counts, bins, _ = plt.hist(df_gspib['GSPIB'], bins=bins,edgecolor='w')
plt.ylabel("Frequências", fontweight='bold')
plt.xlabel("Porcentagem do PIB gasto com saúde", fontweight='bold')
plt.rcParams.update({'font.size': 15})
plt.style.use("fivethirtyeight")
plt.yticks(np.arange(0, 1650, step=160))
plt.xticks(np.arange(0, 55, step=5))
for n, b in zip(counts, bins):
        n = int(n)
        plt.gca().text(b+1.1, n + 35, str(n), color='black', fontweight='bold',fontsize=12)


plt.show()

display(df_gspib.info())

display(df_gspib['Date'].value_counts().sort_index())

display(df_gspib['GSPIB'].value_counts().sort_index())

df_gspib

"""# **[3] --- TRANSFORMAÇÃO DE DADOS**

# **Criação da Primeira Amostra**
"""

sample_A = df_chikv.copy()
sample_A

sample_A=pd.merge(
    sample_A,
    df_idh,
    how="right",
    on = None,
    left_on=['Country' , 'Date'],
    right_on=['Country' , 'Date'],
)

sample_A=pd.merge(
    sample_A,
    df_bs,
    how="right",
    on = None,
    left_on=['Country' , 'Date'],
    right_on=['Country' , 'Date'],
)

sample_A=pd.merge(
    sample_A,
    df_gspib,
    how="right",
    on = None,
    left_on=['Country' , 'Date'],
    right_on=['Country' , 'Date'],
)

sample_A

sample_A = sample_A.drop(columns=['Acession','Gender','Age','Date'])
sample_A

sample_A.isnull().sum()

sample_A = sample_A.dropna(subset=['Genotype','Host','IDH','ASB'])
sample_A = sample_A.reset_index(drop=True)
sample_A

sample_A = sample_A.drop(columns=['Host'])
sample_A

"""**Últimas Correções**"""

sample_A = sample_A.astype({"Genotype": str,"Country":str, 
                              "IDH": float, "ASB": float, "GSPIB": float})

display(sample_A.info())

sample_A.GSPIB = sample_A.GSPIB / 100
sample_A.ASB = sample_A.ASB / 100

sample_A.IDH = sample_A.IDH.round(2)
sample_A.ASB = sample_A.ASB.round(2)
sample_A.GSPIB = sample_A.GSPIB.round(2)

sample_A

sample_A.to_csv(r'/content/amostra_A.csv', index = False)

"""# **Criação da Segunda Amostra**"""

sample_B = df_chikv.copy()
sample_B

sample_B=pd.merge(
    sample_B,
    df_idh,
    how="right",
    on = None,
    left_on=['Country' , 'Date'],
    right_on=['Country' , 'Date'],
)

sample_B=pd.merge(
    sample_B,
    df_bs,
    how="right",
    on = None,
    left_on=['Country' , 'Date'],
    right_on=['Country' , 'Date'],
)

sample_B=pd.merge(
    sample_B,
    df_gspib,
    how="right",
    on = None,
    left_on=['Country' , 'Date'],
    right_on=['Country' , 'Date'],
)

sample_B

sample_B = sample_B.drop(columns=['Acession','Date'])
sample_B

sample_B.isnull().sum()

sample_B = sample_B.dropna(subset=['Genotype','Host','IDH','ASB','Gender','Age'])
sample_B = sample_B.reset_index(drop=True)
sample_B

sample_B = sample_B.drop(columns=['Host'])
sample_B

"""**Últimas Correções**"""

sample_B = sample_B.astype({"Genotype": str,"Country":str, 
                              "IDH": float, "ASB": float, "GSPIB": float,"Gender":str, "Age":int})

display(sample_B.info())

sample_B.GSPIB = sample_B.GSPIB / 100
sample_B.ASB = sample_B.ASB / 100

sample_B.IDH = sample_B.IDH.round(2)
sample_B.ASB= sample_B.ASB.round(2)
sample_B.GSPIB = sample_B.GSPIB.round(2)

sample_B

sample_B.to_csv(r'/content/amostra_B.csv', index = False)

"""# **Criação da Terceira Amostra**"""

sample_C = df_chikv.copy()
sample_C

diagnostic=pd.read_excel('/content/Diagnostic.xls')
diagnostic

sample_C=pd.merge(
    sample_C,
    df_idh,
    how="right",
    on = None,
    left_on=['Country' , 'Date'],
    right_on=['Country' , 'Date'],
)

sample_C=pd.merge(
    sample_C,
    df_bs,
    how="right",
    on = None,
    left_on=['Country' , 'Date'],
    right_on=['Country' , 'Date'],
)

sample_C=pd.merge(
    sample_C,
    df_gspib,
    how="right",
    on = None,
    left_on=['Country' , 'Date'],
    right_on=['Country' , 'Date'],
)

sample_C

sample_C=pd.merge(
    sample_C,
    diagnostic,
    how="left",
    on = "Acession"
)

sample_C

sample_C = sample_C.drop(columns=['Age','Gender','Date'])
sample_C

sample_C.isnull().sum()

sample_C = sample_C.dropna(subset=['Genotype','Host','IDH','ASB',"Symptom"])
sample_C = sample_C.reset_index(drop=True)
sample_C

sample_C = sample_C.drop(columns=['Host'])
sample_C

"""**Últimas Correções**"""

sample_C = sample_C.astype({"Genotype": str,"Country":str, 
                              "IDH": float, "ASB": float, "GSPIB": float,"Symptom":str})

display(sample_C.info())

sample_C.GSPIB = sample_C.GSPIB / 100
sample_C.ASB = sample_C.ASB / 100

sample_C.IDH = sample_C.IDH.round(2)
sample_C.ASB = sample_C.ASB.round(2)
sample_C.GSPIB = sample_C.GSPIB.round(2)

sample_C

sample_C.to_csv(r'/content/amostra_C.csv', index = False)

"""# **Criação da Quarta Amostra**"""

sample_D = df_chikv
sample_D

df_sintomas = pd.read_excel('/content/Diagnostic.xls')
df_sintomas

sample_D=pd.merge(
    sample_D,
    df_sintomas,
    how="left",
    on = 'Acession',
)

sample_D

sample_D['Symptom'] = sample_D['Symptom'].fillna('asymptomatic')
sample_D

for linha in range(len(sample_D)):
  if (sample_D.loc[linha,'Symptom']=='asymptomatic'):
    if (pd.isnull(sample_D.loc[linha,'Host'])):
      sample_D.drop([linha],inplace=True)

sample_D.isnull().sum()

sample_D = sample_D.dropna(subset=['Date'])
sample_D = sample_D.drop(columns=['Gender','Age','Host'])
sample_D = sample_D.reset_index(drop=True)
sample_D

sample_D.isnull().sum()

sample_D = sample_D.astype({"Symptom": str,"Genotype":str, "Country":str})

display(sample_D.info())

sample_D=pd.merge(
    sample_D,
    df_idh,
    how="left",
    on = None,
    left_on=['Country' , 'Date'],
    right_on=['Country' , 'Date'],
)

sample_D=pd.merge(
    sample_D,
    df_bs,
    how="left",
    on = None,
    left_on=['Country' , 'Date'],
    right_on=['Country' , 'Date'],
)

sample_D=pd.merge(
    sample_D,
    df_gspib,
    how="left",
    on = None,
    left_on=['Country' , 'Date'],
    right_on=['Country' , 'Date'],
)

sample_D

sample_D.isnull().sum()

sample_D = sample_D.drop(columns=['Date'])
sample_D = sample_D.dropna(subset=['IDH','ASB','GSPIB'])
sample_D = sample_D.reset_index(drop=True)
sample_D

sample_D.GSPIB = sample_D.GSPIB / 100
sample_D.ASB = sample_D.ASB / 100

sample_D.IDH = sample_D.IDH.round(2)
sample_D.ASB= sample_D.ASB.round(2)
sample_D.GSPIB = sample_D.GSPIB.round(2)

sample_D

sample_D.to_csv(r'/content/amostra_D.csv', index = False)

"""# **[ANTIGO] Criação da Primeira Amostra**"""

df_socioec = df_idh
df_socioec

df_socioec=pd.merge(
    df_socioec,
    df_bs,
    how="left",
    on = ['Country' , 'Date'],
)

df_socioec=pd.merge(
    df_socioec,
    df_gspib,
    how="left",
    on = ['Country' , 'Date'],
)

df_socioec

df_socioec.isnull().sum()

df_socioec = df_socioec.dropna(subset=['ASB','GSPIB'])

df_socioec = df_socioec.astype({"Country":str, "Date": str, 
                              "IDH": float, "ASB": float, "GSPIB": float})

display(df_socioec.info())

df_socioec = df_socioec.groupby(['Country']).mean().round(2)
df_socioec = df_socioec.reset_index(drop=False)

df_socioec

df_socioec.GSPIB = df_socioec.GSPIB / 100
df_socioec.ASB = df_socioec.ASB / 100

df_socioec.ASB = df_socioec.ASB.round(2)
df_socioec.GSPIB = df_socioec.GSPIB.round(2)

df_socioec

df_socioec.to_csv(r'/content/dfsocioec.csv', index = False)

sample_A = df_chikv
sample_A

sample_A=pd.merge(
    sample_A,
    df_socioec,
    how="left",
    on = ['Country'],
)

sample_A

sample_A = sample_A.drop(columns=['Acession','Gender','Age'])
sample_A

sample_A.isnull().sum()

sample_A = sample_A.dropna(subset=['Date','IDH','ASB','GSPIB','Host'])
sample_A = sample_A.reset_index(drop=True)
sample_A

sample_A = sample_A.astype({"Genotype": str,"Country":str, "Date": int, 
                              "IDH": float, "ASB": float, "GSPIB": float})

sample_A.info()

sample_A.drop(sample_A[(sample_A['Date'] < 2004) | (sample_A['Date']>2017)].index,inplace=True)
sample_A = sample_A.drop(columns=['Date','Host'])
sample_A = sample_A.reset_index(drop="True")

sample_A

sample_A.to_csv(r'/content/sample_A.csv', index = False)

"""# **[4] --- MINERAÇÃO DE DADOS**

# **Funções para os Experimentos**

**Método do cotovelo**
"""

def elbowKPrototype(mx,catColumns):
  cost = []
  for cluster in range(1,11):
    try:
      kprototype=KPrototypes(n_clusters=clusters,init='Huang',verbose=1,n_init=1000)
      kprototype.fit_predict(mx, categorical=catColumns)
      cost.append(kprototype.cost_)

    except:
      break
  
  return cost

"""**Função para Execução do KPrototype**"""

def execKPrototype(matrix,nClusters,colunas_c,exec):
  for i in range(0, exec):
    try:
      print('----------------------')
      print('Execução: {}'.format(i+1))
      kprototype = KPrototypes(n_clusters = nClusters, init = 'Huang',verbose=1, n_init=1)
      kprototype.fit_predict(matrix, categorical=colunas_c)
      clusters.append(kprototype.labels_)
      costs.append(kprototype.cost_)

    except:
        break

"""# **Primeira Amostra: Preparação para os Experimentos**

**Exibição da Primeira Amostra**
"""

sample_A = pd.read_csv('/content/amostra_A.csv',sep=',')
sample_A

"""**Verificar a quantidade de valores unitários de cada coluna**"""

sample_A.select_dtypes('object').nunique()

"""**Descrever os valores das variáveis numéricas**"""

sample_A.describe()

"""**Verificar a quantidade de valores nulos**"""

sample_A.isna().sum()

"""**Variação dos valores de genótipo**"""

display(sample_A['Genotype'].value_counts())

"""**Busca pelas colunas categóricas do dataframe**"""

catColumns_A = [sample_A.columns.get_loc(col) for col in list(sample_A.select_dtypes('object').columns)]
print('Categorical columns           : {}'.format(list(sample_A.select_dtypes('object').columns)))
print('Categorical columns position  : {}'.format(catColumns_A))

"""**Converter de dataframe para uma matriz**"""

mx_sample_A = sample_A.to_numpy()
mx_sample_A

"""**Método do cotovelo para identificar a quantidade de clusters**"""

cost_A = elbowKprototype(mx_sample_A,catColumns_A)

"""**Impressão do gráfico representando o método do cotovelo**"""

cost_A=[572.1334853094421,
369.5733071964135,
235.04185520197188,
201.13818910398265,
180.8406081753923,
162.59766708265755,
144.37395673123845,
128.67068936897059,
115.81242330482463,
105.08435947190868]

cost_A

ax = plt.subplots(figsize=(8, 5))
 plt.rcParams.update({'font.size': 14})
 plt.style.use("fivethirtyeight")
 plt.plot(range(1, 11), cost_A,linewidth=2)
 plt.xticks(range(1, 11))
 plt.xlabel("Número de Clusters")
 plt.ylabel("Custo")
 plt.show()

arquivo = open('custos_A_elbow.txt', 'w')
conteudo = list()
for item in cost_A:
  conteudo.append(str(item)+'\n')

arquivo.writelines(conteudo)
arquivo.close()

"""**Percepções após o método do cotovelo:**

*   A quantidade ideal de clusters após a análise para esta amostra é de **3 clusters**
*   Para avaliar os clusters, serão utilizadas as métricas:
> **Índice de Rand, de Jaccard e F-Measure**
*   Serão aplicadas as métricas em 3 etapas: com **100**, **500** e **1000** execuções

># **Primeira Amostra: 100 Execuções**

**Criação das listas que irão armazenar os clusters e os custos. Logo após, a execução do algoritmo**
"""

clusters= []
costs= []

execKPrototype(mx_sample_A,3,catColumns_A,100)

"""**Listagem de todos os custos para os clusters gerados**"""

costs

"""**Listagem de todos os clusters gerados**"""

clusters

"""**Exportação dos custos gerados para serem utilizados na interpretação dos resultados**"""

arquivo = open('costs_A_100.txt', 'w')
conteudo = list()
for item in costs:
  conteudo.append(str(item)+'\n')

arquivo.writelines(conteudo)
arquivo.close()

"""**Exportação dos clusters gerados para serem utilizados na interpretação dos resultados**"""

np.savetxt('clusters_A_100.txt',clusters,fmt='%d')

"""># **Primeira Amostra: 500 Execuções**

**Criação das listas que irão armazenar os clusters e os custos. Logo após, a execução do algoritmo**
"""

clusters=[]
costs=[]
iterations=[]

execKPrototype(mx_sample_A,3,catColumns_A,500)

clusters_A_500 = clusters
costs_A_500 = costs
iterations_A_500 = iterations

"""**Listagem de todos os custos para os clusters gerados**"""

costs_A_500

"""**Listagem de todos os clusters gerados**"""

clusters_A_500

"""**Listagem de todas as iterações para convergir em cada uma dos agrupamentos**"""

iterations_A_500

"""**Exportação dos custos gerados para serem utilizados na interpretação dos resultados**"""

arquivo = open('custos_A_500.txt', 'w')
conteudo = list()
for item in costs_A_500:
  conteudo.append(str(item)+'\n')

arquivo.writelines(conteudo)
arquivo.close()

"""**Exportação dos clusters gerados para serem utilizados na interpretação dos resultados**"""

np.savetxt('clusters_A_500.txt',clusters_A_500,fmt='%d')

"""**Exportação das iterações em cada um dos agrupamentos para serem utilizados na interpretação dos resultados**"""

arquivo = open('iteracoes_A_500.txt', 'w')
conteudo = list()
for item in iterations_A_500:
  conteudo.append(str(item)+'\n')

arquivo.writelines(conteudo)
arquivo.close()

"""># **Primeira Amostra: 1000 Execuções**

**Criação das listas que irão armazenar os clusters e os custos. Logo após, a execução do algoritmo**
"""

clusters=[]
costs=[]
iterations=[]

execKPrototype(mx_sample_A,3,catColumns_A,1000)

clusters_A_1000 = clusters
costs_A_1000 = costs
iterations_A_1000 = iterations

"""**Listagem de todos os custos para os clusters gerados**"""

costs_A_1000

"""**Listagem de todos os clusters gerados**"""

clusters_A_1000

"""**Listagem de todas as iterações para convergir em cada uma dos agrupamentos**"""

iterations_A_1000

"""**Exportação dos custos gerados para serem utilizados na interpretação dos resultados**"""

arquivo = open('custos_A_1000.txt', 'w')
conteudo = list()
for item in costs_A_1000:
  conteudo.append(str(item)+'\n')

arquivo.writelines(conteudo)
arquivo.close()

"""**Exportação dos clusters gerados para serem utilizados na interpretação dos resultados**"""

np.savetxt('clusters_A_1000.txt',clusters_A_1000,fmt='%d')

"""**Exportação das iterações em cada um dos agrupamentos para serem utilizados na interpretação dos resultados**"""

arquivo = open('iteracoes_A_1000.txt', 'w')
conteudo = list()
for item in iterations_A_1000:
  conteudo.append(str(item)+'\n')

arquivo.writelines(conteudo)
arquivo.close()

"""# **Segunda Amostra: Preparação para os Experimentos**

**Exibição da Segunda Amostra**
"""

sample_B = pd.read_csv('/content/amostra_B.csv',sep=',')
sample_B

"""**Verificar a quantidade de valores unitários de cada coluna**"""

sample_B.select_dtypes('object').nunique()

"""**Descrever os valores das variáveis numéricas**"""

sample_B.describe()

"""**Verificar a quantidade de valores nulos**"""

sample_B.isna().sum()

display(sample_B['Genotype'].value_counts())

"""**Converter de dataframe para uma matriz**"""

mx_sample_B = sample_B.to_numpy()
mx_sample_B

catColumns_B = [sample_B.columns.get_loc(col) for col in list(sample_B.select_dtypes('object').columns)]
print('Categorical columns           : {}'.format(list(sample_B.select_dtypes('object').columns)))
print('Categorical columns position  : {}'.format(catColumns_B))

"""**Método do cotovelo para identificar a quantidade de clusters**"""

cost_B = elbowKprototype(mx_sample_B,catColumns_B)

"""**Impressão do gráfico representando o método do cotovelo**"""

cost_B = [99774.68152078136,
28739.929091287973,
12723.094421667853,
8001.797328470232,
5987.956477423431,
4464.902929915799,
3418.6289703365915,
2990.7060179091627,
2751.355564759201,
2560.5726537714036]

cost_B

ax = plt.subplots(figsize=(8, 6))
 plt.rcParams.update({'font.size': 12})
 plt.style.use("fivethirtyeight")
 plt.plot(range(1, 11), cost_B,linewidth=2)
 plt.xticks(range(1, 11))
 plt.xlabel("Número de Clusters")
 plt.ylabel("Custo")
 plt.show()

arquivo = open('custos_B_elbow.txt', 'w')
conteudo = list()
for item in cost_B:
  conteudo.append(str(item)+'\n')

arquivo.writelines(conteudo)
arquivo.close()

"""**Percepções após o método do cotovelo:**

*   A quantidade ideal de clusters após a análise para esta amostra é de **2 clusters**
*   Para avaliar os clusters, serão utilizadas as métricas:
> **Índice de Rand, de Jaccard e F-Measure**
*   Serão aplicadas as métricas em 3 etapas: com **100**, **500** e **1000** execuções

># **Segunda Amostra: 100 Execuções**

**Criação das listas que irão armazenar os clusters e os custos. Logo após, a execução do algoritmo**
"""

clusters= []
costs= []

execKPrototype(mx_sample_B,3,catColumns_B,100)

"""**Listagem de todos os custos para os clusters gerados**"""

costs

"""**Listagem de todos os clusters gerados**"""

clusters

"""**Exportação dos custos gerados para serem utilizados na interpretação dos resultados**"""

arquivo = open('costs_B_100.txt', 'w')
conteudo = list()
for item in costs:
  conteudo.append(str(item)+'\n')

arquivo.writelines(conteudo)
arquivo.close()

"""**Exportação dos clusters gerados para serem utilizados na interpretação dos resultados**"""

np.savetxt('clusters_B_100.txt',clusters,fmt='%d')

"""># **Segunda Amostra: 500 Execuções**

**Criação das listas que irão armazenar os clusters e os custos. Logo após, a execução do algoritmo**
"""

clusters=[]
costs=[]
iterations=[]

execKModes(mx_sample_B,3,500)

clusters_B_500 = clusters
costs_B_500 = costs
iterations_B_500 = iterations

"""**Listagem de todos os custos para os clusters gerados**"""

costs_B_500

"""**Listagem de todos os clusters gerados**"""

clusters_B_500

"""**Listagem de todas as iterações para convergir em cada uma dos agrupamentos**"""

iterations_B_500

"""**Exportação dos custos gerados para serem utilizados na interpretação dos resultados**"""

arquivo = open('custos_B_500.txt', 'w')
conteudo = list()
for item in costs_B_500:
  conteudo.append(str(item)+'\n')

arquivo.writelines(conteudo)
arquivo.close()

"""**Exportação dos clusters gerados para serem utilizados na interpretação dos resultados**"""

np.savetxt('clusters_B_500.txt',clusters_B_500,fmt='%d')

"""**Exportação das iterações em cada um dos agrupamentos para serem utilizados na interpretação dos resultados**"""

arquivo = open('iteracoes_B_500.txt', 'w')
conteudo = list()
for item in iterations_B_500:
  conteudo.append(str(item)+'\n')

arquivo.writelines(conteudo)
arquivo.close()

"""># **Segunda Amostra: 1000 Execuções**

**Criação das listas que irão armazenar os clusters e os custos. Logo após, a execução do algoritmo**
"""

clusters=[]
costs=[]
iterations=[]

execKModes(mx_sample_B,3,1000)

clusters_B_1000 = clusters
costs_B_1000 = costs
iterations_B_1000 = iterations

"""**Listagem de todos os custos para os clusters gerados**"""

costs_B_1000

"""**Listagem de todos os clusters gerados**"""

clusters_B_1000

"""**Listagem de todas as iterações para convergir em cada uma dos agrupamentos**"""

iterations_B_1000

"""**Exportação dos custos gerados para serem utilizados na interpretação dos resultados**"""

arquivo = open('custos_B_1000.txt', 'w')
conteudo = list()
for item in costs_B_1000:
  conteudo.append(str(item)+'\n')

arquivo.writelines(conteudo)
arquivo.close()

"""**Exportação dos clusters gerados para serem utilizados na interpretação dos resultados**"""

np.savetxt('clusters_B_1000.txt',clusters_B_1000,fmt='%d')

"""**Exportação das iterações em cada um dos agrupamentos para serem utilizados na interpretação dos resultados**"""

arquivo = open('iteracoes_B_1000.txt', 'w')
conteudo = list()
for item in iterations_B_1000:
  conteudo.append(str(item)+'\n')

arquivo.writelines(conteudo)
arquivo.close()

"""# **Terceira Amostra: Preparação para os Experimentos**

**Exibição da Terceira Amostra**
"""

sample_C = pd.read_csv('/content/amostra_C.csv',sep=',')
sample_C

"""**Verificar a quantidade de valores unitários de cada coluna**"""

sample_C.select_dtypes('object').nunique()

"""**Verificar a quantidade de valores nulos**"""

sample_C.isna().sum()

display(sample_C['Country'].value_counts())

display(sample_C['Genotype'].value_counts())

"""**Converter de dataframe para uma matriz**"""

mx_sample_C = sample_C.to_numpy()
mx_sample_C

catColumns_C = [sample_C.columns.get_loc(col) for col in list(sample_C.select_dtypes('object').columns)]
print('Categorical columns           : {}'.format(list(sample_C.select_dtypes('object').columns)))
print('Categorical columns position  : {}'.format(catColumns_C))

"""**Método do cotovelo para identificar a quantidade de clusters**"""

cost_C = elbowKprototype(mx_sample_C,catColumns_C)

"""**Impressão do gráfico representando o método do cotovelo**"""

cost_C =[147.16252248136408,
96.36514572229763,
84.12903718837639,
73.89656645514832,
68.25114547950362,
63.32145621873946,
59.578433027005495,
56.06792423969422,
52.47712792556358,
49.76029102230953]

ax = plt.subplots(figsize=(8, 6))
 plt.rcParams.update({'font.size': 12})
 plt.style.use("fivethirtyeight")
 plt.plot(range(1, 11), cost_C,linewidth=2)
 plt.xticks(range(1, 11))
 plt.xlabel("Número de Clusters")
 plt.ylabel("Custo")
 plt.show()

arquivo = open('custos_C_elbow.txt', 'w')
conteudo = list()
for item in cost_C:
  conteudo.append(str(item)+'\n')

arquivo.writelines(conteudo)
arquivo.close()

"""**Percepções após o método do cotovelo:**

*   A quantidade ideal de clusters após a análise para esta amostra é de **2 clusters**
*   Para avaliar os clusters, serão utilizadas as métricas:
> **Índice de Rand, de Jaccard e F-Measure**
*   Serão aplicadas as métricas em 3 etapas: com **100**, **500** e **1000** execuções

># **Terceira Amostra: 100 Execuções**

**Criação das listas que irão armazenar os clusters e os custos. Logo após, a execução do algoritmo**
"""

clusters=[]
costs=[]

execKPrototype(mx_sample_C,2,catColumns_C,100)

clusters_C_100 = clusters
costs_C_100 = costs

"""**Listagem de todos os custos para os clusters gerados**"""

costs_C_100

"""**Listagem de todos os clusters gerados**"""

clusters_C_100

"""**Exportação dos custos gerados para serem utilizados na interpretação dos resultados**"""

arquivo = open('custos_C_100.txt', 'w')
conteudo = list()
for item in costs_C_100:
  conteudo.append(str(item)+'\n')

arquivo.writelines(conteudo)
arquivo.close()

"""**Exportação dos clusters gerados para serem utilizados na interpretação dos resultados**"""

np.savetxt('clusters_C_100.txt',clusters_C_100,fmt='%d')



"""># **Terceira Amostra: 500 Execuções**

**Criação das listas que irão armazenar os clusters e os custos. Logo após, a execução do algoritmo**
"""

clusters=[]
costs=[]
iterations=[]

execKModes(mx_sample_C,2,500)

clusters_C_500 = clusters
costs_C_500 = costs
iterations_C_500 = iterations

"""**Listagem de todos os custos para os clusters gerados**"""

costs_C_500

"""**Listagem de todos os clusters gerados**"""

clusters_C_500

"""**Listagem de todas as iterações para convergir em cada uma dos agrupamentos**"""

iterations_C_500

"""**Exportação dos custos gerados para serem utilizados na interpretação dos resultados**"""

arquivo = open('custos_C_500.txt', 'w')
conteudo = list()
for item in costs_C_500:
  conteudo.append(str(item)+'\n')

arquivo.writelines(conteudo)
arquivo.close()

"""**Exportação dos clusters gerados para serem utilizados na interpretação dos resultados**"""

np.savetxt('clusters_C_500.txt',clusters_C_500,fmt='%d')

"""**Exportação das iterações em cada um dos agrupamentos para serem utilizados na interpretação dos resultados**"""

arquivo = open('iteracoes_C_500.txt', 'w')
conteudo = list()
for item in iterations_C_500:
  conteudo.append(str(item)+'\n')

arquivo.writelines(conteudo)
arquivo.close()

"""># **Terceira Amostra: 1000 Execuções**

**Criação das listas que irão armazenar os clusters e os custos. Logo após, a execução do algoritmo**
"""

clusters=[]
costs=[]
iterations=[]

execKModes(mx_sample_C,2,1000)

clusters_C_1000 = clusters
costs_C_1000 = costs
iterations_C_1000 = iterations

"""**Listagem de todos os custos para os clusters gerados**"""

costs_C_1000

"""**Listagem de todos os clusters gerados**"""

clusters_C_1000

"""**Listagem de todas as iterações para convergir em cada uma dos agrupamentos**"""

iterations_C_1000

"""**Exportação dos custos gerados para serem utilizados na interpretação dos resultados**"""

arquivo = open('custos_C_1000.txt', 'w')
conteudo = list()
for item in costs_C_1000:
  conteudo.append(str(item)+'\n')

arquivo.writelines(conteudo)
arquivo.close()

"""**Exportação dos clusters gerados para serem utilizados na interpretação dos resultados**"""

np.savetxt('clusters_C_1000.txt',clusters_C_1000,fmt='%d')

"""**Exportação das iterações em cada um dos agrupamentos para serem utilizados na interpretação dos resultados**"""

arquivo = open('iteracoes_C_1000.txt', 'w')
conteudo = list()
for item in iterations_C_1000:
  conteudo.append(str(item)+'\n')

arquivo.writelines(conteudo)
arquivo.close()

"""# **Quarta Amostra: Preparação para os Experimentos**

**Exibição da Quarta Amostra**
"""

sample_D = pd.read_csv('/content/amostra_D.csv',sep=',')
sample_D

"""**Verificar a quantidade de valores unitários de cada coluna**"""

sample_D.select_dtypes('object').nunique()

"""**Descrever os valores das variáveis numéricas**"""

sample_D.describe()

"""**Verificar a quantidade de valores nulos**"""

sample_D.isna().sum()

display(sample_D['Genotype'].value_counts())

"""**Busca pelas colunas categóricas do dataframe**"""

catColumns_D = [sample_D.columns.get_loc(col) for col in list(sample_D.select_dtypes('object').columns)]
print('Categorical columns           : {}'.format(list(sample_D.select_dtypes('object').columns)))
print('Categorical columns position  : {}'.format(catColumns_D))

"""**Converter de dataframe para uma matriz**"""

mx_sample_D = sample_D.to_numpy()
mx_sample_D

"""**Método do cotovelo para identificar a quantidade de clusters**"""

cost_D = elbowKprototype(mx_sample_D,catColumns_D)

"""**Impressão do gráfico representando o método do cotovelo**"""

cost_D = [726.8913855341149,
490.59069636643073,
350.3988878769199,
315.81997591664805,
290.3749429871877,
269.9944873167769,
248.58151654331814,
230.00945806439486,
227.6624960041239,
216.08275802807088]

ax = plt.subplots(figsize=(8, 6))
 plt.rcParams.update({'font.size': 12})
 plt.style.use("fivethirtyeight")
 plt.plot(range(1, 11), cost_D,linewidth=2)
 plt.xticks(range(1, 11))
 plt.xlabel("Número de Clusters")
 plt.ylabel("Custo")
 plt.show()

cost_D = []
arquivo = open('custos_D_elbow.txt', 'w')
conteudo = list()
for item in cost_D:
  conteudo.append(str(item)+'\n')

arquivo.writelines(conteudo)
arquivo.close()

"""**Percepções após o método do cotovelo:**

*   A quantidade ideal de clusters após a análise para esta amostra é de **3 clusters**
*   Para avaliar os clusters, serão utilizadas as métricas:
> **Índice de Rand, de Jaccard e F-Measure**
*   Serão aplicadas as métricas em 3 etapas: com **100**, **500** e **1000** execuções

># **Quarta Amostra: 100 Execuções**

**Criação das listas que irão armazenar os clusters e os custos. Logo após, a execução do algoritmo**
"""

clusters=[]
costs=[]

execKPrototype(mx_sample_D,3,catColumns_D,100)

clusters_D_100 = clusters
costs_D_100 = costs

"""**Listagem de todos os custos para os clusters gerados**"""

costs_D_100

"""**Listagem de todos os clusters gerados**"""

clusters_D_100

"""**Exportação dos custos gerados para serem utilizados na interpretação dos resultados**"""

arquivo = open('custos_D_100.txt', 'w')
conteudo = list()
for item in costs_D_100:
  conteudo.append(str(item)+'\n')

arquivo.writelines(conteudo)
arquivo.close()

"""**Exportação dos clusters gerados para serem utilizados na interpretação dos resultados**"""

np.savetxt('clusters_D_100.txt',clusters_D_100,fmt='%d')

"""># **Quarta Amostra: 500 Execuções**

**Criação das listas que irão armazenar os clusters e os custos. Logo após, a execução do algoritmo**
"""

clusters=[]
costs=[]
iterations=[]

execKPrototype(mx_sample_D,3,catColumns_D,500)

clusters_D_500 = clusters
costs_D_500 = costs
iterations_D_500 = iterations

"""**Listagem de todos os custos para os clusters gerados**"""

costs_D_500

"""**Listagem de todos os clusters gerados**"""

clusters_D_500

"""**Listagem de todas as iterações para convergir em cada uma dos agrupamentos**"""

iterations_D_500

"""**Exportação dos custos gerados para serem utilizados na interpretação dos resultados**"""

arquivo = open('custos_D_500.txt', 'w')
conteudo = list()
for item in costs_D_500:
  conteudo.append(str(item)+'\n')

arquivo.writelines(conteudo)
arquivo.close()

"""**Exportação dos clusters gerados para serem utilizados na interpretação dos resultados**"""

np.savetxt('clusters_D_500.txt',clusters_D_500,fmt='%d')

"""**Exportação das iterações em cada um dos agrupamentos para serem utilizados na interpretação dos resultados**"""

arquivo = open('iteracoes_D_500.txt', 'w')
conteudo = list()
for item in iterations_D_500:
  conteudo.append(str(item)+'\n')

arquivo.writelines(conteudo)
arquivo.close()

"""># **Quarta Amostra: 1000 Execuções**

**Criação das listas que irão armazenar os clusters e os custos. Logo após, a execução do algoritmo**
"""

clusters=[]
costs=[]
iterations=[]

execKPrototype(mx_sample_D,3,catColumns_D,1000)

clusters_D_1000 = clusters
costs_D_1000 = costs
iterations_D_1000 = iterations

"""**Listagem de todos os custos para os clusters gerados**"""

costs_D_1000

"""**Listagem de todos os clusters gerados**"""

clusters_D_1000

"""**Listagem de todas as iterações para convergir em cada uma dos agrupamentos**"""

iterations_D_1000

"""**Exportação dos custos gerados para serem utilizados na interpretação dos resultados**"""

arquivo = open('custos_D_1000.txt', 'w')
conteudo = list()
for item in costs_D_1000:
  conteudo.append(str(item)+'\n')

arquivo.writelines(conteudo)
arquivo.close()

"""**Exportação dos clusters gerados para serem utilizados na interpretação dos resultados**"""

np.savetxt('clusters_D_1000.txt',clusters_D_1000,fmt='%d')

"""**Exportação das iterações em cada um dos agrupamentos para serem utilizados na interpretação dos resultados**"""

arquivo = open('iteracoes_D_1000.txt', 'w')
conteudo = list()
for item in iterations_D_1000:
  conteudo.append(str(item)+'\n')

arquivo.writelines(conteudo)
arquivo.close()

"""# **[5] --- AVALIAÇÃO DO ALGORITMO**

# **Funções para aplicação das métricas**

**Função para encontrar o menor custo entre os clusters gerados na execução**
"""

def lowestCost(cost):
  lowest_cost = 0
  for item in range(len(cost)):
    if cost[item] < cost[lowest_cost]:
     lowest_cost = item
  
  return lowest_cost

"""**Função para encontrar a quantidade de clusters com o melhor custo**"""

def qtdClusters(cost, best_cost):
  qtdClusters = 0
  for item in range(len(cost)):
    if cost[item] == best_cost:
     qtdClusters = qtdClusters + 1
  
  return qtdClusters

"""**Função para avaliar o algoritmo com o uso do Índice de Jaccard**"""

def jaccardIndex(clusters, best_result):
  jaccard = []
  for item in range(len(clusters)):
    score = jaccard_score(best_result, clusters[item],average='macro')
    jaccard.append(score)
  
  return jaccard

"""**Função para avaliar o algoritmo com o uso do Índice de Rand Ajustado**"""

def randIndex(clusters,best_result):
  rand = []
  for item in range(len(clusters)):
    score = adjusted_rand_score(best_result, clusters[item])
    rand.append(score)

  return rand

"""**Histograma de frequência para as métricas**"""

def histogramaRand(ax):
  ax = ax[0]
  for x in ax:

      # Despine
      x.spines['right'].set_visible(False)
      x.spines['top'].set_visible(False)
      x.spines['left'].set_visible(False)

      # Switch off ticks
      x.tick_params(axis="both", which="both", bottom="off", top="off", labelbottom="on", left="off", right="off", labelleft="on")

      # Draw horizontal axis lines
      vals = x.get_yticks()
      for tick in vals:
          x.axhline(y=tick, alpha=0.4, color='#B8B7B6', zorder=1)

      # Remove title
      x.set_title("")

      # Set x-axis label
      x.set_xlabel("Índice de Rand", labelpad=20, weight='bold', size=12)

      # Set y-axis label
      x.set_ylabel("Frequência", labelpad=20, weight='bold', size=12)

      # Format y-axis label
      x.yaxis.set_major_formatter(StrMethodFormatter('{x:,g}'))

def histogramaJaccard(ax):
  ax = ax[0]
  for x in ax:

      # Despine
      x.spines['right'].set_visible(False)
      x.spines['top'].set_visible(False)
      x.spines['left'].set_visible(False)

      # Switch off ticks
      x.tick_params(axis="both", which="both", bottom="off", top="off", labelbottom="on", left="off", right="off", labelleft="on")

      # Draw horizontal axis lines
      vals = x.get_yticks()
      for tick in vals:
          x.axhline(y=tick, alpha=0.4, color='#B8B7B6', zorder=1)

      # Remove title
      x.set_title("")

      # Set x-axis label
      x.set_xlabel("Índice de Jaccard", labelpad=20, weight='bold', size=12)

      # Set y-axis label
      x.set_ylabel("Frequência", labelpad=20, weight='bold', size=12)

      # Format y-axis label
      x.yaxis.set_major_formatter(StrMethodFormatter('{x:,g}'))

def histogramaf1(ax):
  ax = ax[0]
  for x in ax:

      # Despine
      x.spines['right'].set_visible(False)
      x.spines['top'].set_visible(False)
      x.spines['left'].set_visible(False)

      # Switch off ticks
      x.tick_params(axis="both", which="both", bottom="off", top="off", labelbottom="on", left="off", right="off", labelleft="on")

      # Draw horizontal axis lines
      vals = x.get_yticks()
      for tick in vals:
          x.axhline(y=tick, alpha=0.4, color='#B8B7B6', zorder=1)

      # Remove title
      x.set_title("")

      # Set x-axis label
      x.set_xlabel("F1 Measure", labelpad=20, weight='bold', size=12)

      # Set y-axis label
      x.set_ylabel("Frequência", labelpad=20, weight='bold', size=12)

      # Format y-axis label
      x.yaxis.set_major_formatter(StrMethodFormatter('{x:,g}'))

"""**Identificação dos clusters perfeitos**"""

def perfectClusters(df_metricas):
  perfect_clusters = 0
  for linha in range(len(df_metricas)):
    if ((df_metricas.loc[linha,'Rand']== 1) & (df_metricas.loc[linha,'Jaccard']== 1)):
      perfect_clusters = perfect_clusters + 1

  return perfect_clusters

def imperfectClusters(df_metricas):
  imperfect_clusters = 0
  for linha in range(len(df_metricas)):
    if ((df_metricas.loc[linha,'Rand']== 0) & (df_metricas.loc[linha,'Jaccard']== 0)):
      imperfect_clusters = imperfect_clusters + 1

  return imperfect_clusters

"""# **Sobre as métricas**

**As métricas escolhidas foram baseadas no trabalho de Fábio, e medem a similaridade dos clusters criados pelos algoritmos em suas execuções**

**Índice de Rand Ajustado:**


1.   O Índice de Rand calcula o grau de similaridade entre o agrupamento **R** de um conjunto de dados cuja classificação é conhecida a priori e que servirá como referência, e o agrupamento C gerado pelo algoritmo que se pretende avaliar.
2.   Já o Índice de Rand Ajustado foi proposto por Hubert e Arabie (1985), os quais determinaram o valor esperado do Indice de Rand, dando origem ao Índice de
Rand Ajsutado, visto que no Índice de Rand o valor esperado não é nulo para duas
partições completamente aleatórias de um conjunto de dados. 
3.  Examinando a qual grupo os dados pertencem nos dois grupos, se duas informações pertencerem ao mesmo grupo o valor do Índice aumenta; por
outro lado, se as duas pertencerem, ao mesmo grupo em uma partição, mas pertencem a grupo diferentes em outra, o valor do Índice diminui.
4. Este índice assume valores em [−1, 1], onde o valor 1 indica um perfeito acordo entre as duas partições, enquanto que valores próximos de 0 correspondem a um acordo entre as partições devido ao acaso.

**Índice de Jaccard:**


1.   O Índice de similaridade Jaccard indica a semelhanca entre dois agrupamentos, comparando a quantidade de informações entre as partições utilizadas em seu cálculo e a quantidade de informações exclusivas para cada partição e o número de informações em comum entre elas.
2.   O coeficiente de similaridade de Jaccard é definido pela razão entre o número de elementos da intersecçãao e o número de elementos da união

**O que é o custo no algoritmo?**

O custo em geral é uma medida dos dados de entrada na função objetivo, ou seja, alguma forma de distância dentro do cluster em relação à distância interna do cluster .

># **Primeira Amostra: Avaliaçao das 100 Execuções**

**Importação e Impressão dos custos**
"""

arquivo = open("custos_A_100.txt", "r")
costs_A_100 = arquivo.readlines()
arquivo.close

for i in range(len(costs_A_100)):
  costs_A_100[i] = float(costs_A_100[i])

"""**Importação e Impressão dos clusters**"""

clusters_A_100 = np.loadtxt('clusters_A_100.txt', dtype=int)

"""**Identificação do menor custo e de sua posição**"""

best_cost_A_100 = lowestCost(costs_A_100)
print('Cluster: {}'.format(best_cost_A_100+1))
print('Custo: {}'.format(costs_A_100[best_cost_A_100]))

"""**Impressão do melhor cluster encontrado**"""

best_cluster_A_100 = clusters_A_100[best_cost_A_100]
best_cluster_A_100

"""**Aplicação das Métricas**"""

metrics_A_100 = pd.DataFrame()
metrics_A_100['Rand'] = randIndex(clusters_A_100,best_cluster_A_100)
metrics_A_100['Jaccard'] = jaccardIndex(clusters_A_100,best_cluster_A_100)

"""**Quantificação dos resultados com o Índice de Rand**"""

display(metrics_A_100['Rand'].value_counts().sort_index())

"""**Quantificação dos resultados com o Índice de Jaccard**"""

display(metrics_A_100['Jaccard'].value_counts())

"""**Clusters Perfeitos**"""

perfect_clusters_A_100 = perfectClusters(metrics_A_100)
print("Clusters Perfeitos: ", perfect_clusters_A_100)

metrics_A_100.describe()

qtdClusters_A_100 = qtdClusters(costs_A_100,costs_A_100[best_cost_A_100])
print('Foram encontrados com o melhor custo: {} clusters'.format(qtdClusters_A_100))

"""># **Primeira Amostra: Avaliaçao das 500 Execuções**

**Importação e Impressão dos custos**
"""

arquivo = open("custos_A_500.txt", "r")
costs_A_500 = arquivo.readlines()
arquivo.close

for i in range(len(costs_A_500)):
  costs_A_500[i] = float(costs_A_500[i])

"""**Importação e Impressão dos clusters**"""

clusters_A_500 = np.loadtxt('clusters_A_500.txt', dtype=int)

"""**Identificação do menor custo e de sua posição**"""

best_cost_A_500 = lowestCost(costs_A_500)
print('Cluster: {}'.format(best_cost_A_500+1))
print('Custo: {}'.format(costs_A_500[best_cost_A_500]))

"""**Impressão do melhor cluster encontrado**"""

best_cluster_A_500 = clusters_A_500[best_cost_A_500]
best_cluster_A_500

"""**Aplicação das Métricas**"""

metrics_A_500 = pd.DataFrame()
metrics_A_500['Rand'] = randIndex(clusters_A_500,best_cluster_A_500)
metrics_A_500['Jaccard'] = jaccardIndex(clusters_A_500,best_cluster_A_500)

"""**Quantificação dos resultados com o Índice de Rand**"""

display(metrics_A_500['Rand'].value_counts().sort_index())

"""**Quantificação dos resultados com o Índice de Jaccard**"""

display(metrics_A_500['Jaccard'].value_counts().sort_index())

"""**Clusters Perfeitos e Imperfeitos**"""

perfect_clusters_A_500 = perfectClusters(metrics_A_500)
print("Clusters Perfeitos: ", perfect_clusters_A_500)

metrics_A_500.describe()

qtdClusters_A_500 = qtdClusters(costs_A_500,costs_A_500[best_cost_A_500])
print('Foram encontrados com o melhor custo: {} clusters'.format(qtdClusters_A_500))

"""># **Primeira Amostra: Avaliaçao das 1000 Execuções**

**Importação e Impressão dos custos**
"""

arquivo = open("custos_A_1000.txt", "r")
costs_A_1000 = arquivo.readlines()
arquivo.close

for i in range(len(costs_A_1000)):
  costs_A_1000[i] = float(costs_A_1000[i])

"""**Importação e Impressão dos clusters**"""

clusters_A_1000 = np.loadtxt('clusters_A_1000.txt', dtype=int)

"""**Identificação do menor custo e de sua posição**"""

best_cost_A_1000 = lowestCost(costs_A_1000)
print('Cluster: {}'.format(best_cost_A_1000+1))
print('Custo: {}'.format(costs_A_1000[best_cost_A_1000]))

"""**Impressão do melhor cluster encontrado**"""

best_cluster_A_1000 = clusters_A_1000[best_cost_A_1000]
best_cluster_A_1000

"""**Aplicação das Métricas**"""

metrics_A_1000 = pd.DataFrame()
metrics_A_1000['Rand'] = randIndex(clusters_A_1000,best_cluster_A_1000)
metrics_A_1000['Jaccard'] = jaccardIndex(clusters_A_1000,best_cluster_A_1000)

"""**Quantificação dos resultados com o Índice de Rand**"""

display(metrics_A_1000['Rand'].value_counts().sort_index())

"""**Quantificação dos resultados com o Índice de Jaccard**"""

display(metrics_A_1000['Jaccard'].value_counts().sort_index())

"""**Clusters Perfeitos e Imperfeitos**"""

perfect_clusters_A_1000 = perfectClusters(metrics_A_1000)
print("Clusters Perfeitos: ", perfect_clusters_A_1000)

metrics_A_1000.describe()

qtdClusters_A_1000 = qtdClusters(costs_A_1000,costs_A_1000[best_cost_A_1000])
print('Foram encontrados com o melhor custo: {} clusters'.format(qtdClusters_A_1000))

"""># **Segunda Amostra: Avaliaçao das 100 Execuções**

**Importação e Impressão dos custos**
"""

arquivo = open("custos_B_100.txt", "r")
costs_B_100 = arquivo.readlines()
arquivo.close

for i in range(len(costs_B_100)):
  costs_B_100[i] = float(costs_B_100[i])

"""**Importação e Impressão dos clusters**"""

clusters_B_100 = np.loadtxt('clusters_B_100.txt', dtype=int)

"""**Identificação do menor custo e de sua posição**"""

best_cost_B_100 = lowestCost(costs_B_100)
print('Cluster: {}'.format(best_cost_B_100+1))
print('Custo: {}'.format(costs_B_100[best_cost_B_100]))

"""**Impressão do melhor cluster encontrado**"""

best_cluster_B_100 = clusters_B_100[best_cost_B_100]
best_cluster_B_100

"""**Aplicação das Métricas**"""

metrics_B_100 = pd.DataFrame()
metrics_B_100['Rand'] = randIndex(clusters_B_100,best_cluster_B_100)
metrics_B_100['Jaccard'] = jaccardIndex(clusters_B_100,best_cluster_B_100)

"""**Quantificação dos resultados com o Índice de Rand**"""

display(metrics_B_100['Rand'].value_counts().sort_index())

"""**Quantificação dos resultados com o Índice de Jaccard**"""

display(metrics_B_100['Jaccard'].value_counts())

"""**Clusters Perfeitos**"""

perfect_clusters_B_100 = perfectClusters(metrics_B_100)
print("Clusters Perfeitos: ", perfect_clusters_B_100)

metrics_B_100.describe()

qtdClusters_B_100 = qtdClusters(costs_B_100,costs_B_100[best_cost_B_100])
print('Foram encontrados com o melhor custo: {} clusters'.format(qtdClusters_B_100))

"""># **Segunda Amostra: Avaliaçao das 500 Execuções**

**Importação e Impressão dos custos**
"""

arquivo = open("custos_B_500.txt", "r")
costs_B_500 = arquivo.readlines()
arquivo.close

for i in range(len(costs_B_500)):
  costs_B_500[i] = float(costs_B_500[i])

"""**Importação e Impressão dos clusters**"""

clusters_B_500 = np.loadtxt('clusters_B_500.txt', dtype=int)

"""**Identificação do menor custo e de sua posição**"""

best_cost_B_500 = lowestCost(costs_B_500)
print('Cluster: {}'.format(best_cost_B_500+1))
print('Custo: {}'.format(costs_B_500[best_cost_B_500]))

"""**Impressão do melhor cluster encontrado**"""

best_cluster_B_500 = clusters_B_500[best_cost_B_500]
best_cluster_B_500

"""**Aplicação das Métricas**"""

metrics_B_500 = pd.DataFrame()
metrics_B_500['Rand'] = randIndex(clusters_B_500,best_cluster_B_500)
metrics_B_500['Jaccard'] = jaccardIndex(clusters_B_500,best_cluster_B_500)

"""**Quantificação dos resultados com o Índice de Rand**"""

display(metrics_B_500['Rand'].value_counts().sort_index())

"""**Quantificação dos resultados com o Índice de Jaccard**"""

display(metrics_B_500['Jaccard'].value_counts().sort_index())

"""**Clusters Perfeitos e Imperfeitos**"""



perfect_clusters_B_500 = perfectClusters(metrics_B_500)
print("Clusters Perfeitos: ", perfect_clusters_B_500)

metrics_B_500.describe()

"""**Melhores clusters encontrados**"""

qtdClusters_B_500 = qtdClusters(costs_B_500,costs_B_500[best_cost_B_500])
print('Foram encontrados com o melhor custo: {} clusters'.format(qtdClusters_B_500))

"""># **Segunda Amostra: Avaliaçao das 1000 Execuções**

**Importação e Impressão dos custos**
"""

arquivo = open("custos_B_1000.txt", "r")
costs_B_1000 = arquivo.readlines()
arquivo.close

for i in range(len(costs_B_1000)):
  costs_B_1000[i] = float(costs_B_1000[i])

"""**Importação e Impressão dos clusters**"""

clusters_B_1000 = np.loadtxt('clusters_B_1000.txt', dtype=int)

"""**Identificação do menor custo e de sua posição**"""

best_cost_B_1000 = lowestCost(costs_B_1000)
print('Cluster: {}'.format(best_cost_B_1000+1))
print('Custo: {}'.format(costs_B_1000[best_cost_B_1000]))

"""**Impressão do melhor cluster encontrado**"""

best_cluster_B_1000 = clusters_B_1000[best_cost_B_1000]
best_cluster_B_1000

"""**Aplicação das Métricas**"""

metrics_B_1000 = pd.DataFrame()
metrics_B_1000['Rand'] = randIndex(clusters_B_1000,best_cluster_B_1000)
metrics_B_1000['Jaccard'] = jaccardIndex(clusters_B_1000,best_cluster_B_1000)

"""**Quantificação dos resultados com o Índice de Rand**"""

display(metrics_B_1000['Rand'].value_counts().sort_index())

"""**Quantificação dos resultados com o Índice de Jaccard**"""

display(metrics_B_1000['Jaccard'].value_counts().sort_index())

"""**Clusters Perfeitos e Imperfeitos**"""

perfect_clusters_B_1000 = perfectClusters(metrics_B_1000)
print("Clusters Perfeitos: ", perfect_clusters_B_1000)

metrics_B_1000.describe()

qtdClusters_B_1000 = qtdClusters(costs_B_1000,costs_B_1000[best_cost_B_1000])
print('Foram encontrados com o melhor custo: {} clusters'.format(qtdClusters_B_1000))

"""># **Terceira Amostra: Avaliaçao das 100 Execuções**

**Importação e Impressão dos custos**
"""

arquivo = open("custos_C_100.txt", "r")
costs_C_100 = arquivo.readlines()
arquivo.close

for i in range(len(costs_C_100)):
  costs_C_100[i] = float(costs_C_100[i])

"""**Importação e Impressão dos clusters**"""

clusters_C_100 = np.loadtxt('clusters_C_100.txt', dtype=int)

"""**Identificação do menor custo e de sua posição**"""

best_cost_C_100 = lowestCost(costs_C_100)
print('Cluster: {}'.format(best_cost_C_100+1))
print('Custo: {}'.format(costs_C_100[best_cost_C_100]))

"""**Impressão do melhor cluster encontrado**"""

best_cluster_C_100 = clusters_C_100[best_cost_C_100]
best_cluster_C_100

"""**Aplicação das Métricas**"""

metrics_C_100 = pd.DataFrame()
metrics_C_100['Rand'] = randIndex(clusters_C_100,best_cluster_C_100)
metrics_C_100['Jaccard'] = jaccardIndex(clusters_C_100,best_cluster_C_100)

"""**Quantificação dos resultados com o Índice de Rand**"""

display(metrics_C_100['Rand'].value_counts().sort_index())

"""**Quantificação dos resultados com o Índice de Jaccard**"""

display(metrics_C_100['Jaccard'].value_counts().sort_index())

"""**Clusters Perfeitos**"""

perfect_clusters_C_100 = perfectClusters(metrics_C_100)
print("Clusters Perfeitos: ", perfect_clusters_C_100)

metrics_C_100.describe()

qtdClusters_C_100 = qtdClusters(costs_C_100,costs_C_100[best_cost_C_100])
print('Foram encontrados com o melhor custo: {} clusters'.format(qtdClusters_C_100))

"""># **Terceira Amostra: Avaliaçao das 500 Execuções**

**Importação e Impressão dos custos**
"""

arquivo = open("custos_C_500.txt", "r")
costs_C_500 = arquivo.readlines()
arquivo.close

for i in range(len(costs_C_500)):
  costs_C_500[i] = float(costs_C_500[i])

"""**Importação e Impressão dos clusters**"""

clusters_C_500 = np.loadtxt('clusters_C_500.txt', dtype=int)

"""**Identificação do menor custo e de sua posição**"""

best_cost_C_500 = lowestCost(costs_C_500)
print('Cluster: {}'.format(best_cost_C_500+1))
print('Custo: {}'.format(costs_C_500[best_cost_C_500]))

"""**Impressão do melhor cluster encontrado**"""

best_cluster_C_500 = clusters_C_500[best_cost_C_500]
best_cluster_C_500

"""**Aplicação das Métricas**"""

metrics_C_500 = pd.DataFrame()
metrics_C_500['Rand'] = randIndex(clusters_C_500,best_cluster_C_500)
metrics_C_500['Jaccard'] = jaccardIndex(clusters_C_500,best_cluster_C_500)

"""**Quantificação dos resultados com o Índice de Rand**"""

display(metrics_C_500['Rand'].value_counts().sort_index())

"""**Quantificação dos resultados com o Índice de Jaccard**"""

display(metrics_C_500['Jaccard'].value_counts().sort_index())

"""**Clusters Perfeitos e Imperfeitos**"""

perfect_clusters_C_500 = perfectClusters(metrics_C_500)
print("Clusters Perfeitos: ", perfect_clusters_C_500)

metrics_C_500.describe()

qtdClusters_C_500 = qtdClusters(costs_C_500,costs_C_500[best_cost_C_500])
print('Foram encontrados com o melhor custo: {} clusters'.format(qtdClusters_C_500))

"""># **Terceira Amostra: Avaliaçao das 1000 Execuções**

**Importação e Impressão dos custos**
"""

arquivo = open("custos_C_1000.txt", "r")
costs_C_1000 = arquivo.readlines()
arquivo.close

for i in range(len(costs_C_1000)):
  costs_C_1000[i] = float(costs_C_1000[i])

"""**Importação e Impressão dos clusters**"""

clusters_C_1000 = np.loadtxt('clusters_C_1000.txt', dtype=int)

"""**Identificação do menor custo e de sua posição**"""

best_cost_C_1000 = lowestCost(costs_C_1000)
print('Cluster: {}'.format(best_cost_C_1000+1))
print('Custo: {}'.format(costs_C_1000[best_cost_C_1000]))

"""**Impressão do melhor cluster encontrado**"""

best_cluster_C_1000 = clusters_C_1000[best_cost_C_1000]
best_cluster_C_1000

"""**Aplicação das Métricas**"""

metrics_C_1000 = pd.DataFrame()
metrics_C_1000['Rand'] = randIndex(clusters_C_1000,best_cluster_C_1000)
metrics_C_1000['Jaccard'] = jaccardIndex(clusters_C_1000,best_cluster_C_1000)

"""**Quantificação dos resultados com o Índice de Rand**"""

display(metrics_C_1000['Rand'].value_counts().sort_index())

"""**Quantificação dos resultados com o Índice de Jaccard**"""

display(metrics_C_1000['Jaccard'].value_counts().sort_index())

"""**Clusters Perfeitos**"""

perfect_clusters_C_1000 = perfectClusters(metrics_C_1000)
print("Clusters Perfeitos: ", perfect_clusters_C_1000)

metrics_C_1000.describe()

qtdClusters_C_1000 = qtdClusters(costs_C_1000,costs_C_1000[best_cost_C_1000])
print('Foram encontrados com o melhor custo: {} clusters'.format(qtdClusters_C_1000))

"""># **Quarta Amostra: Avaliaçao das 100 Execuções**

**Importação e Impressão dos custos**
"""

arquivo = open("custos_D_100.txt", "r")
costs_D_100 = arquivo.readlines()
arquivo.close

for i in range(len(costs_D_100)):
  costs_D_100[i] = float(costs_D_100[i])

"""**Importação e Impressão dos clusters**"""

clusters_D_100 = np.loadtxt('clusters_D_100.txt', dtype=int)

"""**Identificação do menor custo e de sua posição**"""

best_cost_D_100 = lowestCost(costs_D_100)
print('Cluster: {}'.format(best_cost_D_100+1))
print('Custo: {}'.format(costs_D_100[best_cost_D_100]))

"""**Impressão do melhor cluster encontrado**"""

best_cluster_D_100 = clusters_D_100[best_cost_D_100]
best_cluster_D_100

"""**Aplicação das Métricas**"""

metrics_D_100 = pd.DataFrame()
metrics_D_100['Rand'] = randIndex(clusters_D_100,best_cluster_D_100)
metrics_D_100['Jaccard'] = jaccardIndex(clusters_D_100,best_cluster_D_100)

"""**Quantificação dos resultados com o Índice de Rand**"""

display(metrics_D_100['Rand'].value_counts().sort_index())

"""**Quantificação dos resultados com o Índice de Jaccard**"""

display(metrics_D_100['Jaccard'].value_counts().sort_index())

"""**Clusters Perfeitos**"""

perfect_clusters_D_100 = perfectClusters(metrics_D_100)
print("Clusters Perfeitos: ", perfect_clusters_D_100)

metrics_D_100.describe()

qtdClusters_D_100 = qtdClusters(costs_D_100,costs_D_100[best_cost_D_100])
print('Foram encontrados com o melhor custo: {} clusters'.format(qtdClusters_D_100))

"""># **Quarta Amostra: Avaliaçao das 500 Execuções**

**Importação e Impressão dos custos**
"""

arquivo = open("custos_D_500.txt", "r")
costs_D_500 = arquivo.readlines()
arquivo.close

for i in range(len(costs_D_500)):
  costs_D_500[i] = float(costs_D_500[i])

"""**Importação e Impressão dos clusters**"""

clusters_D_500 = np.loadtxt('clusters_D_500.txt', dtype=int)
clusters_D_500

"""**Identificação do menor custo e de sua posição**"""

best_cost_D_500 = lowestCost(costs_D_500)
print('Cluster: {}'.format(best_cost_D_500+1))
print('Custo: {}'.format(costs_D_500[best_cost_D_500]))

"""**Impressão do melhor cluster encontrado**"""

best_cluster_D_500 = clusters_D_500[best_cost_D_500]
best_cluster_D_500

"""**Aplicação das Métricas**"""

metrics_D_500 = pd.DataFrame()
metrics_D_500['Rand'] = randIndex(clusters_D_500,best_cluster_D_500)
metrics_D_500['Jaccard'] = jaccardIndex(clusters_D_500,best_cluster_D_500)

"""**Quantificação dos resultados com o Índice de Rand**"""

display(metrics_D_500['Rand'].value_counts().sort_index())

"""**Quantificação dos resultados com o Índice de Jaccard**"""

display(metrics_D_500['Jaccard'].value_counts().sort_index())

"""**Clusters Perfeitos**"""

perfect_clusters_D_500 = perfectClusters(metrics_D_500)

print("Clusters Perfeitos: ", perfect_clusters_D_500)

metrics_D_500.describe()

qtdClusters_D_500 = qtdClusters(costs_D_500,costs_D_500[best_cost_D_500])
print('Foram encontrados com o melhor custo: {} clusters'.format(qtdClusters_D_500))

"""># **Quarta Amostra: Avaliaçao das 1000 Execuções**

**Importação e Impressão dos custos**
"""

arquivo = open("custos_D_1000.txt", "r")
costs_D_1000 = arquivo.readlines()
arquivo.close

for i in range(len(costs_D_1000)):
  costs_D_1000[i] = float(costs_D_1000[i])

"""**Importação e Impressão dos clusters**"""

clusters_D_1000 = np.loadtxt('clusters_D_1000.txt', dtype=int)

"""**Identificação do menor custo e de sua posição**"""

best_cost_D_1000 = lowestCost(costs_D_1000)
print('Cluster: {}'.format(best_cost_D_1000+1))
print('Custo: {}'.format(costs_D_1000[best_cost_D_1000]))

"""**Impressão do melhor cluster encontrado**"""

best_cluster_D_1000 = clusters_D_1000[best_cost_D_1000]
best_cluster_D_1000

"""**Aplicação das Métricas**"""

metrics_D_1000 = pd.DataFrame()
metrics_D_1000['Rand'] = randIndex(clusters_D_1000,best_cluster_D_1000)
metrics_D_1000['Jaccard'] = jaccardIndex(clusters_D_1000,best_cluster_D_1000)

"""**Quantificação dos resultados com o Índice de Rand**"""

display(metrics_D_1000['Rand'].value_counts().sort_index())

"""**Quantificação dos resultados com o Índice de Jaccard**"""

display(metrics_D_1000['Jaccard'].value_counts().sort_index())

"""**Clusters Perfeitos**"""

perfect_clusters_D_1000 = perfectClusters(metrics_D_1000)

print("Clusters Perfeitos: ", perfect_clusters_D_1000)

qtdClusters_D_1000 = qtdClusters(costs_D_1000,costs_D_1000[best_cost_D_1000])
print('Foram encontrados com o melhor custo: {} clusters'.format(qtdClusters_D_1000))

metrics_D_1000.describe()

"""# **[6] --- Resultados da Avaliação das métricas---**

# **Resultados para o Índice de Rand**

**Levantamento das médias do Índice de Rand Ajustado para a amostra ex1**
"""

rand_B_100 = metrics_B_100['Rand'].mean()
rand_B_500 = metrics_B_500['Rand'].mean()
rand_B_1000 = metrics_B_1000['Rand'].mean()

rand_B_100 = round(rand_B_100,4)
rand_B_500 = round(rand_B_500,4)
rand_B_1000 = round(rand_B_1000,4)

print (rand_B_100)
print (rand_B_500)
print (rand_B_1000)

"""**Levantamento das médias do Índice de Rand Ajustado para a segunda amostra**"""

rand_C_100 = metrics_C_100['Rand'].mean()
rand_C_500 = metrics_C_500['Rand'].mean()
rand_C_1000 = metrics_C_1000['Rand'].mean()

rand_C_100 = round(rand_C_100,4)
rand_C_500 = round(rand_C_500,4)
rand_C_1000 = round(rand_C_1000,4)

print (rand_C_100)
print (rand_C_500)
print (rand_C_1000)

"""**Levantamento das médias do Índice de Rand Ajustado para a terceira amostra**"""

rand_D_100 = metrics_D_100['Rand'].mean()
rand_D_500 = metrics_D_500['Rand'].mean()
rand_D_1000 = metrics_D_1000['Rand'].mean()

rand_D_100 = round(rand_D_100,4)
rand_D_500 = round(rand_D_500,4)
rand_D_1000 = round(rand_D_1000,4)

print (rand_D_100)
print (rand_D_500)
print (rand_D_1000)

"""**Levantamento das médias do Índice de Rand Ajustado para a quarta amostra**"""

rand_A_100 = metrics_A_100['Rand'].mean()
rand_A_500 = metrics_A_500['Rand'].mean()
rand_A_1000 = metrics_A_1000['Rand'].mean()

rand_A_100 = round(rand_A_100,4)
rand_A_500 = round(rand_A_500,4)
rand_A_1000 = round(rand_A_1000,4)

print (rand_A_100)
print (rand_A_500)
print (rand_A_1000)

"""**Gráfico para as métricas**"""

ax = plt.subplots(figsize=(10, 8))

# linha para Rand
x1 = [100,500,1000]
y1 = [rand_A_100,rand_A_500,rand_A_1000]
plt.plot(x1, y1, label = "Primeira Amostra", linewidth = 2,
         marker='o', markersize=8,color='blue')
for x,y in zip(x1,y1):

    label = "{:.4f}".format(y)

    plt.annotate(label, 
                 (x,y),
                 textcoords='offset points',
                 xytext=(10,20),
                 ha='center', 
                 va='top',
                 color='white',
                 size=12,
                 bbox=dict(boxstyle='round,pad=0.2', fc='blue', alpha=0.5))
    


# linha para Rand
x1 = [100,500,1000]
y1 = [rand_B_100,rand_B_500,rand_B_1000]
plt.plot(x1, y1, label = "Segunda Amostra", linewidth = 2,
         marker='o', markersize=8,color='red')
for x,y in zip(x1,y1):

    label = "{:.4f}".format(y)

    plt.annotate(label, 
                 (x,y),
                 textcoords='offset points',
                 xytext=(10,10),
                 ha='center', 
                 va='baseline',
                 color='white',
                 size=12,
                 bbox=dict(boxstyle='round,pad=0.2', fc='red', alpha=0.5))

# linha para Rand
x1 = [100,500,1000]
y1 = [rand_C_100,rand_C_500,rand_C_1000]
plt.plot(x1, y1, label = "Terceira Amostra", linewidth = 2,
         marker='o', markersize=8,color='purple')
for x,y in zip(x1,y1):

    label = "{:.4f}".format(y)

    plt.annotate(label, 
                 (x,y),
                 textcoords='offset points',
                 xytext=(10,-10),
                 ha='center', 
                 va='top',
                 color='white',
                 size=12,
                 bbox=dict(boxstyle='round,pad=0.2', fc='purple', alpha=0.5))
    
# linha para Rand
x1 = [100,500,1000]
y1 = [rand_D_100,rand_D_500,rand_D_1000]
plt.plot(x1, y1, label = "Quarta Amostra", linewidth = 2,
         marker='o', markersize=8,color='green')
for x,y in zip(x1,y1):

    label = "{:.4f}".format(y)

    plt.annotate(label, 
                 (x,y),
                 textcoords='offset points',
                 xytext=(10,17),
                 ha='center', 
                 va='top',
                 color='white',
                 size=12,
                 bbox=dict(boxstyle='round,pad=0.2', fc='green', alpha=0.5))




plt.xticks(x1,['A', 'B', 'C'])
plt.yticks(np.arange(0.5, 1.05, step=0.05))
# naming the x axis
plt.xlabel('Experimentos',fontweight='bold',labelpad=10)
# naming the y axis
plt.ylabel('Média do Índice de Rand Ajustado',fontweight='bold',labelpad=10)

  
# show a legend on the plot
#plt.legend(fontsize=12,frameon=True, loc=(1.05,0.7), ncol=1)
plt.legend(fontsize=12,frameon=True, loc='lower right', ncol=1)

plt.style.use("fivethirtyeight")
# function to show the plot


plt.show()

"""# **Resultados para o Índice de Jaccard**

**Levantamento das médias do Índice de Rand Ajustado para a primeira amostra**
"""

jac_A_100 = metrics_A_100['Jaccard'].mean()
jac_A_500 = metrics_A_500['Jaccard'].mean()
jac_A_1000 = metrics_A_1000['Jaccard'].mean()

jac_A_100 = round(jac_A_100,4)
jac_A_500 = round(jac_A_500,4)
jac_A_1000 = round(jac_A_1000,4)

print (jac_A_100)
print (jac_A_500)
print (jac_A_1000)

"""**Levantamento das médias do Índice de Rand Ajustado para a segunda amostra**"""

jac_B_100 = metrics_B_100['Jaccard'].mean()
jac_B_500 = metrics_B_500['Jaccard'].mean()
jac_B_1000 = metrics_B_1000['Jaccard'].mean()

jac_B_100 = round(jac_B_100,4)
jac_B_500 = round(jac_B_500,4)
jac_B_1000 = round(jac_B_1000,4)

print (jac_B_100)
print (jac_B_500)
print (jac_B_1000)

"""**Levantamento das médias do Índice de Rand Ajustado para a terceira amostra**"""

jac_C_100 = metrics_C_100['Jaccard'].mean()
jac_C_500 = metrics_C_500['Jaccard'].mean()
jac_C_1000 = metrics_C_1000['Jaccard'].mean()

jac_C_100 = round(jac_C_100,4)
jac_C_500 = round(jac_C_500,4)
jac_C_1000 = round(jac_C_1000,4)

print (jac_C_100)
print (jac_C_500)
print (jac_C_1000)

"""**Levantamento das médias do Índice de Rand Ajustado para a quarta amostra**"""

jac_D_100 = metrics_D_100['Jaccard'].mean()
jac_D_500 = metrics_D_500['Jaccard'].mean()
jac_D_1000 = metrics_D_1000['Jaccard'].mean()

jac_D_100 = round(jac_D_100,4)
jac_D_500 = round(jac_D_500,4)
jac_D_1000 = round(jac_D_1000,4)

print (jac_D_100)
print (jac_D_500)
print (jac_D_1000)

"""**Gráfico para as métricas**"""

ax = plt.subplots(figsize=(10, 8))

# linha para Rand
x1 = [100,500,1000]
y1 = [jac_A_100,jac_A_500,jac_A_1000]
plt.plot(x1, y1, label = "Primeira Amostra", linewidth = 2,
         marker='o', markersize=8,color='blue')
i=0
for x,y in zip(x1,y1):

    label = "{:.4f}".format(y)
    if i==2:
      plt.annotate(label, 
                  (x,y),
                  textcoords='offset points',
                  xytext=(30,0),
                  ha='center', 
                  va='top',
                  color='white',
                  size=12,
                  bbox=dict(boxstyle='round,pad=0.2', fc='blue', alpha=0.5))
    elif i==1:
      plt.annotate(label, 
                  (x,y),
                  textcoords='offset points',
                  xytext=(30,10),
                  ha='center', 
                  va='top',
                  color='white',
                  size=12,
                  bbox=dict(boxstyle='round,pad=0.2', fc='blue', alpha=0.5))
    else:
       plt.annotate(label, 
                  (x,y),
                  textcoords='offset points',
                  xytext=(10,20),
                  ha='center', 
                  va='top',
                  color='white',
                  size=12,
                  bbox=dict(boxstyle='round,pad=0.2', fc='blue', alpha=0.5))
    i=i+1

    # linha para Rand
x1 = [100,500,1000]
y1 = [jac_B_100,jac_B_500,jac_B_1000]
plt.plot(x1, y1, label = "Segunda Amostra", linewidth = 2,
         marker='o', markersize=8,color='red')
i=0
for x,y in zip(x1,y1):

    label = "{:.4f}".format(y)
    if i==2:
      plt.annotate(label, 
                  (x,y),
                  textcoords='offset points',
                  xytext=(-25,20),
                  ha='center', 
                  va='top',
                  color='white',
                  size=12,
                  bbox=dict(boxstyle='round,pad=0.2', fc='red', alpha=0.5))
    elif i==1:
       plt.annotate(label, 
                  (x,y),
                  textcoords='offset points',
                  xytext=(10,20),
                  ha='center', 
                  va='top',
                  color='white',
                  size=12,
                  bbox=dict(boxstyle='round,pad=0.2', fc='red', alpha=0.5))
    else:
        plt.annotate(label, 
            (x,y),
            textcoords='offset points',
            xytext=(10,-10),
            ha='center', 
            va='top',
            color='white',
            size=12,
            bbox=dict(boxstyle='round,pad=0.2', fc='red', alpha=0.5))

    i=i+1

        # linha para Rand
x1 = [100,500,1000]
y1 = [jac_C_100,jac_C_500,jac_C_1000]
plt.plot(x1, y1, label = "Terceira Amostra", linewidth = 2,
         marker='o', markersize=8,color='purple')

for x,y in zip(x1,y1):

    label = "{:.4f}".format(y)
    plt.annotate(label, 
                (x,y),
                textcoords='offset points',
                xytext=(10,20),
                ha='center', 
                va='top',
                color='white',
                size=12,
                bbox=dict(boxstyle='round,pad=0.2', fc='purple', alpha=0.5))


        # linha para Rand
x1 = [100,500,1000]
y1 = [jac_D_100,jac_D_500,jac_D_1000]
plt.plot(x1, y1, label = "Quarta Amostra", linewidth = 2,
         marker='o', markersize=8,color='green')
i=0
for x,y in zip(x1,y1):

    label = "{:.4f}".format(y)
    if i==2:
      plt.annotate(label, 
                  (x,y),
                  textcoords='offset points',
                  xytext=(25,20),
                  ha='center', 
                  va='top',
                  color='white',
                  size=12,
                  bbox=dict(boxstyle='round,pad=0.2', fc='green', alpha=0.5))
    elif i==1:
      plt.annotate(label, 
                  (x,y),
                  textcoords='offset points',
                  xytext=(10,-10),
                  ha='center', 
                  va='top',
                  color='white',
                  size=12,
                  bbox=dict(boxstyle='round,pad=0.2', fc='green', alpha=0.5))
    else:
       plt.annotate(label, 
                  (x,y),
                  textcoords='offset points',
                  xytext=(-25,5),
                  ha='center', 
                  va='top',
                  color='white',
                  size=12,
                  bbox=dict(boxstyle='round,pad=0.2', fc='green', alpha=0.5))
    i=i+1

plt.xticks(x1,['A', 'B', 'C'])
plt.yticks(np.arange(0, 0.55, step=0.05))
# naming the x axis
plt.xlabel('Experimentos',fontweight='bold',labelpad=10)
# naming the y axis
plt.ylabel('Média do Índice de Jaccard',fontweight='bold',labelpad=10)

  
# show a legend on the plot
#plt.legend(fontsize=12,frameon=True, loc=(1.05,0.7), ncol=1)
plt.legend(fontsize=12,frameon=True, loc='lower right', ncol=1)

plt.style.use("fivethirtyeight")
# function to show the plot


plt.show()

"""# **Resultados para os clusters com TS**

**Levantamento da porcentagem de TS para a primeira amostra**
"""

perfect_clusters_A_100 = (perfect_clusters_A_100*100)/100
perfect_clusters_A_500 = (perfect_clusters_A_500*100)/500
perfect_clusters_A_1000 = (perfect_clusters_A_1000*100)/1000

print(perfect_clusters_A_100)
print(perfect_clusters_A_500)
print(perfect_clusters_A_1000)

"""**Levantamento da porcentagem de TS para a segunda amostra**"""

perfect_clusters_B_100 = (perfect_clusters_B_100*100)/100
perfect_clusters_B_500 = (perfect_clusters_B_500*100)/500
perfect_clusters_B_1000 = (perfect_clusters_B_1000*100)/1000

print(perfect_clusters_B_100)
print(perfect_clusters_B_500)
print(perfect_clusters_B_1000)

"""**Levantamento da porcentagem de TS para a terceira amostra**"""

perfect_clusters_C_100 = (perfect_clusters_C_100*100)/100
perfect_clusters_C_500 = (perfect_clusters_C_500*100)/500
perfect_clusters_C_1000 = (perfect_clusters_C_1000*100)/1000

print(perfect_clusters_C_100)
print(perfect_clusters_C_500)
print(perfect_clusters_C_1000)

"""**Levantamento da porcentagem de TS para a quarta amostra**"""

perfect_clusters_D_100 = (perfect_clusters_D_100*100)/100
perfect_clusters_D_500 = (perfect_clusters_D_500*100)/500
perfect_clusters_D_1000 = (perfect_clusters_D_1000*100)/1000

print(perfect_clusters_D_100)
print(perfect_clusters_D_500)
print(perfect_clusters_D_1000)

"""**Gráfico para as métricas**"""

ax = plt.subplots(figsize=(10, 8))

# linha para Rand
x1 = [100,500,1000]
y1 = [perfect_clusters_A_100,perfect_clusters_A_500,perfect_clusters_A_1000]
plt.plot(x1, y1, label = "Primeira Amostra", linewidth = 2,
         marker='o', markersize=8,color='blue')

i=0
for x,y in zip(x1,y1):

    label = "{:.1f}%".format(y)
    if i != 2:
      plt.annotate(label, 
                  (x,y),
                  textcoords='offset points',
                  xytext=(15,8),
                  ha='center', 
                  va='baseline',
                  color='white',
                  size=12,
                  bbox=dict(boxstyle='round,pad=0.2', fc='blue', alpha=0.5))
    
    else:
      plt.annotate(label, 
                  (x,y),
                  textcoords='offset points',
                  xytext=(10,-17),
                  ha='center', 
                  va='baseline',
                  color='white',
                  size=12,
                  bbox=dict(boxstyle='round,pad=0.2', fc='blue', alpha=0.5))
    i=i+1



# linha para Rand
x1 = [100,500,1000]
y1 = [perfect_clusters_B_100,perfect_clusters_B_500,perfect_clusters_B_1000]
plt.plot(x1, y1, label = "Segunda Amostra", linewidth = 2,
         marker='o', markersize=8,color='red')

for x,y in zip(x1,y1):

    label = "{:.1f}%".format(y)

    plt.annotate(label, 
                (x,y),
                textcoords='offset points',
                xytext=(10,10),
                ha='center', 
                va='baseline',
                color='white',
                size=12,
                bbox=dict(boxstyle='round,pad=0.2', fc='red', alpha=0.5))


# linha para Rand
x1 = [100,500,1000]
y1 = [perfect_clusters_C_100,perfect_clusters_C_500,perfect_clusters_C_1000]
plt.plot(x1, y1, label = "Terceira Amostra", linewidth = 2,
         marker='o', markersize=8,color='purple')

for x,y in zip(x1,y1):

    label = "{:.1f}%".format(y)
    plt.annotate(label, 
                (x,y),
                textcoords='offset points',
                xytext=(10,-18),
                ha='center', 
                va='baseline',
                color='white',
                size=12,
                bbox=dict(boxstyle='round,pad=0.2', fc='purple', alpha=0.5))
    

    
# linha para Rand
x1 = [100,500,1000]
y1 = [perfect_clusters_D_100,perfect_clusters_D_500,perfect_clusters_D_1000]
plt.plot(x1, y1, label = "Quarta Amostra", linewidth = 2,
         marker='o', markersize=8,color='green')

i=0
for x,y in zip(x1,y1):

    label = "{:.1f}%".format(y)
    if i == 2:
      plt.annotate(label, 
                  (x,y),
                  textcoords='offset points',
                  xytext=(10,-18),
                  ha='center', 
                  va='baseline',
                  color='white',
                  size=12,
                  bbox=dict(boxstyle='round,pad=0.2', fc='green', alpha=0.5))
    else:
      plt.annotate(label, 
                  (x,y),
                  textcoords='offset points',
                  xytext=(10,-18),
                  ha='center', 
                  va='baseline',
                  color='white',
                  size=12,
                  bbox=dict(boxstyle='round,pad=0.2', fc='green', alpha=0.5))
    i=i+1 


plt.xticks(x1,['A', 'B', 'C'])
plt.yticks(np.arange(0, 22, step=2))
# naming the x axis
plt.xlabel('Experimentos',fontweight='bold',labelpad=10)
# naming the y axis
plt.ylabel('(%) Clusters com Total Similaridade',fontweight='bold',labelpad=10)

  
# show a legend on the plot
plt.legend(fontsize=12,frameon=True, loc='lower right', ncol=1)

plt.style.use("fivethirtyeight")
# function to show the plot


plt.show()

"""# **Resultados para os clusters com MC**

**Levantamento da porcentagem de TS para a primeira amostra**
"""

mc_A_100 = (89*100)/100
mc_A_500 = (437*100)/500
mc_A_1000 = (869*100)/1000

print(mc_A_100)
print(mc_A_500)
print(mc_A_1000)

"""**Levantamento da porcentagem de TS para a segunda amostra**"""

mc_B_100 = (100*100)/100
mc_B_500 = (500*100)/500
mc_B_1000 = (1000*100)/1000

print(mc_B_100)
print(mc_B_500)
print(mc_B_1000)

"""**Levantamento da porcentagem de TS para a terceira amostra**"""

mc_C_100 = (27*100)/100
mc_C_500 = (101*100)/500
mc_C_1000 = (217*100)/1000

print(mc_C_100)
print(mc_C_500)
print(mc_C_1000)

"""**Levantamento da porcentagem de TS para a quarta amostra**"""

mc_D_100 = (78*100)/100
mc_D_500 = (383*100)/500
mc_D_1000 = (752*100)/1000

print(mc_D_100)
print(mc_D_500)
print(mc_D_1000)

"""**Gráfico para as métricas**"""

ax = plt.subplots(figsize=(10, 8))

# linha para Rand
x1 = [100,500,1000]
y1 = [mc_A_100,mc_A_500,mc_A_1000]
plt.plot(x1, y1, label = "Primeira Amostra", linewidth = 2,
         marker='o', markersize=8,color='blue')

for x,y in zip(x1,y1):

  label = "{:.1f}%".format(y)
  plt.annotate(label, 
                (x,y),
                textcoords='offset points',
                xytext=(15,8),
                ha='center', 
                va='baseline',
                color='white',
                size=12,
                bbox=dict(boxstyle='round,pad=0.2', fc='blue', alpha=0.5))



# linha para Rand
x1 = [100,500,1000]
y1 = [mc_B_100,mc_B_500,mc_B_1000]
plt.plot(x1, y1, label = "Segunda Amostra", linewidth = 2,
         marker='o', markersize=8,color='red')

for x,y in zip(x1,y1):

    label = "{:.1f}%".format(y)

    plt.annotate(label, 
                (x,y),
                textcoords='offset points',
                xytext=(10,10),
                ha='center', 
                va='baseline',
                color='white',
                size=12,
                bbox=dict(boxstyle='round,pad=0.2', fc='red', alpha=0.5))


# linha para Rand
x1 = [100,500,1000]
y1 = [mc_C_100,mc_C_500,mc_C_1000]
plt.plot(x1, y1, label = "Terceira Amostra", linewidth = 2,
         marker='o', markersize=8,color='purple')

for x,y in zip(x1,y1):

    label = "{:.1f}%".format(y)
    plt.annotate(label, 
                (x,y),
                textcoords='offset points',
                xytext=(10,-18),
                ha='center', 
                va='baseline',
                color='white',
                size=12,
                bbox=dict(boxstyle='round,pad=0.2', fc='purple', alpha=0.5))
    

    
# linha para Rand
x1 = [100,500,1000]
y1 = [mc_D_100,mc_D_500,mc_D_1000]
plt.plot(x1, y1, label = "Quarta Amostra", linewidth = 2,
         marker='o', markersize=8,color='green')

i=0
for x,y in zip(x1,y1):

    label = "{:.1f}%".format(y)
    if i == 2:
      plt.annotate(label, 
                  (x,y),
                  textcoords='offset points',
                  xytext=(10,-18),
                  ha='center', 
                  va='baseline',
                  color='white',
                  size=12,
                  bbox=dict(boxstyle='round,pad=0.2', fc='green', alpha=0.5))
    else:
      plt.annotate(label, 
                  (x,y),
                  textcoords='offset points',
                  xytext=(10,-18),
                  ha='center', 
                  va='baseline',
                  color='white',
                  size=12,
                  bbox=dict(boxstyle='round,pad=0.2', fc='green', alpha=0.5))
    i=i+1 


plt.xticks(x1,['A', 'B', 'C'])
plt.yticks(np.arange(0, 110, step=10))
# naming the x axis
plt.xlabel('Experimentos',fontweight='bold',labelpad=10)
# naming the y axis
plt.ylabel('(%) Clusters iguais ao referencial',fontweight='bold',labelpad=10)

  
# show a legend on the plot
plt.legend(fontsize=12,frameon=True, loc=[0.85,0.4], ncol=1)

plt.style.use("fivethirtyeight")
# function to show the plot


plt.show()

"""# **[7] --- DESCOBERTA DE CONHECIMENTO ---**

# **Interpretação do agrupamento da Primeira Amostra**
"""

result_A = pd.read_csv('/content/resultados_A.csv',sep=',')
result_A

proto_labs = best_cluster_A_1000

cat_data = sample_A.copy()
for i in cat_data.select_dtypes(include='object'):
    cat_data[i] = cat_data[i].astype('category')


clf_kp = LGBMClassifier(colsample_by_tree=0.8)
cv_scores_kp = cross_val_score(clf_kp, cat_data, proto_labs, scoring='f1_weighted')
print(f'CV F1 score for K-Prototypes clusters is {np.mean(cv_scores_kp)}')

clf_kp.fit(cat_data, proto_labs)

explainer_kp = shap.TreeExplainer(clf_kp)
shap_values_kp = explainer_kp.shap_values(cat_data)

shap.summary_plot(shap_values_kp, cat_data, plot_type="bar", plot_size=(10, 6))

result_A['Segment'] = result_A['Clusters'].map({0:'First', 1:'Second', 2:'Third'})
result_A

result_A['Segment'] = result_A['Segment'].astype('category')
result_A['Segment'] = result_A['Segment'].cat.reorder_categories(['First','Second','Third'])
result_A

analysis_A = result_A.copy()

analysis_A['IDH Min'] = result_A['IDH']
analysis_A['IDH Max'] = result_A['IDH']
analysis_A['ASB Min'] = result_A['ASB']
analysis_A['ASB Max'] = result_A['ASB']
analysis_A['GSPIB Min'] = result_A['GSPIB']
analysis_A['GSPIB Max'] = result_A['GSPIB']

analysis_A

# Cluster interpretation
analysis_A.rename(columns = {'Clusters':'Total','IDH':'IDH mean','ASB':'ASB mean','GSPIB':'GSPIB mean'}, inplace = True)
analysis_A.groupby('Segment').agg(
    {
        'Total':'count',
        'Genotype': lambda x: x.value_counts().index[0],
        'Country': lambda x: x.value_counts().index[0],
        'IDH Min': 'min',
        'IDH Max': 'max',
        'IDH mean': 'mean',
        'ASB Min': 'min',
        'ASB Max': 'max',
        'ASB mean': 'mean',
        'GSPIB Min': 'min',
        'GSPIB Max': 'max',
        'GSPIB mean': 'mean'
    }
).reset_index()

g = sns.catplot(x="IDH",
            y="Genotype",
            hue='Clusters',
            data=result_A,
            s=8, 
            height=7,
            aspect=1.4,
            alpha=0.5,
            palette=sns.color_palette(['#f51720', '#189ab4','orange']))
plt.ylabel("Genótipos", labelpad=10,fontweight='bold')
plt.xlabel("Índice de Desenvolvimento Humando (IDH)", labelpad=10,fontweight='bold')
plt.xticks(np.arange(0, 1.1, step=0.1),size=14)
plt.yticks(size=12)

new_labels = ['1','2','3']
for t, l in zip(g._legend.texts, new_labels): t.set_text(l)

g=sns.catplot(x="ASB",
            y="Genotype",
            hue='Clusters',
            data=result_A,
            s=10, 
            height=7,
            aspect=1.3,
            alpha=0.5,
            kind = 'strip',
            palette=sns.color_palette(['#f51720', '#189ab4','orange']))
plt.ylabel("Genótipos", labelpad=10,fontweight='bold')
plt.xlabel("Acesso a Saneamento Básico (ASB)", labelpad=10,fontweight='bold')
plt.xticks(np.arange(0, 1.1, step=0.1),size=14)
plt.yticks(size=12)

new_labels = ['1','2','3']
for t, l in zip(g._legend.texts, new_labels): t.set_text(l)

sns.catplot(x="GSPIB",
            y="Genotype",
            hue='Clusters',
            data=result_A,
            s=10, 
            height=7,
            aspect=1.3,
            alpha=0.5,
            kind = 'strip',
            palette=sns.color_palette(['#f51720', '#189ab4','orange']))
plt.ylabel("Genótipos", labelpad=10,fontweight='bold')
plt.xlabel("GSPIB", labelpad=10,fontweight='bold')
plt.xticks(np.arange(0, 1.1, step=0.1),size=14)
plt.yticks(size=12)

g = sns.catplot(x="Genotype",
            y="Country",
            hue='Clusters',
            data=result_A,
            height=8.5,
            aspect=1.4,
            s=8, 
            alpha=0.5,
            kind = 'strip',
            palette=sns.color_palette(['#f51720', '#189ab4','orange']))
plt.ylabel("Países", labelpad=10,fontweight='bold')
plt.xlabel("Genótipos", labelpad=10,fontweight='bold')
plt.xticks(size=12)
plt.yticks(size=11)

new_labels = ['1','2','3']
for t, l in zip(g._legend.texts, new_labels): t.set_text(l)

plt.savefig('graf_a_con_gen.png', dpi=300, bbox_inches='tight')
plt.show()

"""**Análises obtidas com a amostra**



---

> **Cluster 0:**


*   Predominância do genótipo **ECSA**, com **97,61%** (1184) dos casos no cluster.
*   Todos os valores do genótipo West African estão contidos neste cluster, o que equivale a **1,24%** dos casos.
*   Característica deste grupo no que tange as variáveis socioeconômicas é o intervalo do IDH que é entre **0.43 e 0.67**, do ASB que é entre **0.06 e 0.67** e do GSPIB que é entre **0.02 e	0.08**.
* O país predominante neste cluster é a Índia, com um total de **83,26%** (1010) dos casos.

> **Cluster 1:**



*   O genótipo **ECSA** é absoluto na amostra, com 100% dos casos (687)
*   Característica deste grupo no que tange as variáveis socioeconômicas é o intervalo do IDH que é entre **0.67 e	0.94**, do ASB que é entre **0.70 e	1.00** e do GSPIB que é entre **0.03 e	0.15**.
* Baseado no IDH e no ASB, é possível observar uma exclusividade no intervalo dos clusters 0 e 1. Porém, no GSPIB, existem valores do mesmo intervalo em ambos.
* Os países que mais aparecem no cluster são a Tailândia com **32,75%** dos casos (225), seguido por Malásia com **15,43%** (106) e Singapura com **14,56%** (100). 
* Os países que estão presentes no cluster 0, não estão presentes no cluster 1. Isso mostra que, para estes dois, existe uma forte tendência as variáveis genótipo, IDH e ASB influenciarem na criação das amostras.

> **Cluster 2:**



*   O genótipo **Asiático** é absoluto na amostra, com 100% dos casos (650)
*   Característica deste grupo no que tange as variáveis socioeconômicas contém valores no intervalo dos dois grupos para o IDH e ASB, removendo a exclusividade que ambas as variáveis tinham nos outros clusters.
* Os países que mais aparecem no cluster são a Nicarágua com **22,92%** dos casos (149), seguido por Estados Unidos com **19,08%** (124) e Indonésia com **12,31%** (100).

**Avaliação Final**

---

> Não foi possível identificar nenhuma relação nesta amostra, pois nenhum dos clusters apresentou exclusividade nas variáveis utilizadas.

> Até para identificar qual das variáveis foi a mais influente para o agrupamento é difícil, pois os valores da maioria das colunas estão presentes nos 3 clusters.

# **Interpretação do agrupamento da Segunda Amostra**
"""

result_B = pd.read_csv('/content/resultados_B.csv',sep=',')
result_B

proto_labs = best_cluster_B_1000

cat_data = sample_B.copy()
for i in cat_data.select_dtypes(include='object'):
    cat_data[i] = cat_data[i].astype('category')


clf_kp = LGBMClassifier(colsample_by_tree=0.8)
cv_scores_kp = cross_val_score(clf_kp, cat_data, proto_labs, scoring='f1_weighted')
print(f'CV F1 score for K-Prototypes clusters is {np.mean(cv_scores_kp)}')

clf_kp.fit(cat_data, proto_labs)

explainer_kp = shap.TreeExplainer(clf_kp)
shap_values_kp = explainer_kp.shap_values(cat_data)

shap.summary_plot(shap_values_kp, cat_data, plot_type="bar", plot_size=(14, 9))

result_B['Segment'] = result_B['Clusters'].map({0:'First', 1:'Second', 2:'Third'})
result_B

result_B['Segment'] = result_B['Segment'].astype('category')
result_B['Segment'] = result_B['Segment'].cat.reorder_categories(['First','Second','Third'])
result_B

analysis_B = result_B.copy()

analysis_B['IDH Min'] = result_B['IDH']
analysis_B['IDH Max'] = result_B['IDH']
analysis_B['ASB Min'] = result_B['ASB']
analysis_B['ASB Max'] = result_B['ASB']
analysis_B['GSPIB Min'] = result_B['GSPIB']
analysis_B['GSPIB Max'] = result_B['GSPIB']
analysis_B['Age Min']=result_B['Age']
analysis_B['Age Max']=result_B['Age']

analysis_B

# Cluster interpretation
analysis_B.rename(columns = {'Clusters':'Total','IDH':'IDH mean','ASB':'ASB mean','GSPIB':'GSPIB mean','Age':'Age mean'}, inplace = True)
analysis_B.groupby('Segment').agg(
    {
        'Total':'count',
        'Genotype': lambda x: x.value_counts().index[0],
        'Country': lambda x: x.value_counts().index[0],
        'Gender': lambda x: x.value_counts().index[0],
        'Age mean': 'mean',
        'Age Min': 'min',
        'Age Max': 'max',
        'IDH Min': 'min',
        'IDH Max': 'max',
        'IDH mean': 'mean',
        'ASB Min': 'min',
        'ASB Max': 'max',
        'ASB mean': 'mean',
        'GSPIB Min': 'min',
        'GSPIB Max': 'max',
        'GSPIB mean': 'mean'
    }
).reset_index()

g = sns.catplot(x="Age",
            y="Genotype",
            hue='Clusters',
            data=result_B,
            s=10, 
            height=7,
            aspect=1.3,
            alpha=0.5,
            kind = 'strip',
            palette=sns.color_palette(['#f51720', '#189ab4','orange']))
plt.ylabel("Genótipos", labelpad=10,fontweight='bold')
plt.xlabel("Idade", labelpad=10,fontweight='bold')
plt.xticks(np.arange(0, 100, step=10),size=14)
plt.yticks(size=12)

new_labels = ['1','2','3']
for t, l in zip(g._legend.texts, new_labels): t.set_text(l)

a = result_B[(result_B.Genotype == 'Asian and Caribbean') & 
             (result_B.Clusters == 2) &
             (result_B.Gender == 'M')].count()['Gender']
b = result_B[(result_B.Genotype == 'Asian and Caribbean') & 
             (result_B.Clusters == 1) &
             (result_B.Gender == 'M')].count()['Gender']
c = result_B[(result_B.Genotype == 'Asian and Caribbean') & 
             (result_B.Clusters == 0) &
             (result_B.Gender == 'M')].count()['Gender']

d = result_B[(result_B.Genotype == 'East-Central-South-African') & 
             (result_B.Clusters == 2) &
             (result_B.Gender == 'M')].count()['Gender']
e = result_B[(result_B.Genotype == 'East-Central-South-African') & 
             (result_B.Clusters == 1) &
             (result_B.Gender == 'M')].count()['Gender']
f = result_B[(result_B.Genotype == 'East-Central-South-African') & 
             (result_B.Clusters == 0) &
             (result_B.Gender == 'M')].count()['Gender']

labels = ['1-21', '23-46', '48-88']
men_means = [a, b, c]
women_means = [d, e, f]

x = np.arange(len(labels))  # the label locations
width = 0.35  # the width of the bars

fig, ax = plt.subplots(figsize=(8, 6))
rects1 = ax.bar(x - width/2, men_means, width, label='Asiático',color='#189ab4',edgecolor='black')
rects2 = ax.bar(x + width/2, women_means, width, label='ECSA', color='#f51720',edgecolor='black')

# Add some text for labels, title and custom x-axis tick labels, etc.
ax.set_xticks(x)
ax.set_xticklabels(labels)
ax.set_yticks(np.arange(0, 101, 10))
ax.legend()

ax.set_ylabel('Frequências',fontweight='bold',labelpad=10)
ax.set_xlabel('Faixas de Idade dos homens',fontweight='bold',labelpad=10)



fig.tight_layout()

plt.show()

a = result_B[(result_B.Genotype == 'Asian and Caribbean') & 
             (result_B.Clusters == 2) &
             (result_B.Gender == 'M')].count()['Gender']
b = result_B[(result_B.Genotype == 'Asian and Caribbean') & 
             (result_B.Clusters == 1) &
             (result_B.Gender == 'M')].count()['Gender']
c = result_B[(result_B.Genotype == 'Asian and Caribbean') & 
             (result_B.Clusters == 0) &
             (result_B.Gender == 'M')].count()['Gender']

d = result_B[(result_B.Genotype == 'East-Central-South-African') & 
             (result_B.Clusters == 2) &
             (result_B.Gender == 'M')].count()['Gender']
e = result_B[(result_B.Genotype == 'East-Central-South-African') & 
             (result_B.Clusters == 1) &
             (result_B.Gender == 'M')].count()['Gender']
f = result_B[(result_B.Genotype == 'East-Central-South-African') & 
             (result_B.Clusters == 0) &
             (result_B.Gender == 'M')].count()['Gender']

N = 3
menMeans = (a, b, c)
womenMeans = (d, e, f)
ind = np.arange(N) # the x locations for the groups
width = 0.35
fig = plt.figure(figsize=(8, 5))
ax = fig.add_axes([0,0,1,1])
ax.bar(ind, menMeans, width, color='#189ab4',edgecolor='black')
ax.bar(ind, womenMeans, width,bottom=menMeans, color='#f51720',edgecolor='black')
ax.set_ylabel('Frequências',fontweight='bold',labelpad=10)
ax.set_xlabel('Faixas de Idade dos homens',fontweight='bold',labelpad=10)
plt.xticks(ind,['1-21', '23-46', '48-88'])
ax.set_yticks(np.arange(0, 101, 10))
ax.legend(labels=['Asiático', 'East-Central-South-African'])
plt.show()

a = result_B[(result_B.Genotype == 'Asian and Caribbean') & 
             (result_B.Clusters == 2) &
             (result_B.Gender == 'F')].count()['Gender']
b = result_B[(result_B.Genotype == 'Asian and Caribbean') & 
             (result_B.Clusters == 1) &
             (result_B.Gender == 'F')].count()['Gender']
c = result_B[(result_B.Genotype == 'Asian and Caribbean') & 
             (result_B.Clusters == 0) &
             (result_B.Gender == 'F')].count()['Gender']

d = result_B[(result_B.Genotype == 'East-Central-South-African') & 
             (result_B.Clusters == 2) &
             (result_B.Gender == 'F')].count()['Gender']
e = result_B[(result_B.Genotype == 'East-Central-South-African') & 
             (result_B.Clusters == 1) &
             (result_B.Gender == 'F')].count()['Gender']
f = result_B[(result_B.Genotype == 'East-Central-South-African') & 
             (result_B.Clusters == 0) &
             (result_B.Gender == 'F')].count()['Gender']

N = 3
menMeans = (a, b, c)
womenMeans = (d, e, f)
ind = np.arange(N) # the x locations for the groups
width = 0.35
fig = plt.figure(figsize=(8, 5))
ax = fig.add_axes([0,0,1,1])
ax.bar(ind, menMeans, width, color='#189ab4',edgecolor='black')
ax.bar(ind, womenMeans, width,bottom=menMeans, color='#f51720',edgecolor='black')
ax.set_ylabel('Frequências',fontweight='bold',labelpad=10)
ax.set_xlabel('Faixas de Idade das mulheres',fontweight='bold',labelpad=10)
plt.xticks(ind,['1-21', '23-46', '48-88'])
ax.set_yticks(np.arange(0, 101, 10))
ax.legend(labels=['Asiático', 'East-Central-South-African'])
plt.show()

g= sns.catplot(x="Age",
            y="Country",
            hue='Clusters',
            data=result_B,
            height=7,
            aspect=1.3,
            s=10, 
            alpha=0.5,
            kind = 'strip',
            palette=sns.color_palette(['#f51720', '#189ab4','orange']))
plt.ylabel("Genótipos", labelpad=10,fontweight='bold')
plt.xlabel("Idade", labelpad=10,fontweight='bold')
plt.xticks(np.arange(0, 100, step=10),size=14)
plt.yticks(size=12)

new_labels = ['1','2','3']
for t, l in zip(g._legend.texts, new_labels): t.set_text(l)

g=sns.catplot(x="Age",
            y="Gender",
            hue='Clusters',
            data=result_B,
            height=7,
            aspect=1.3,
            s=10, 
            alpha=0.5,
            kind = 'strip',
            palette=sns.color_palette(['#f51720', '#189ab4','orange']))
plt.ylabel("Gênero", labelpad=10,fontweight='bold')
plt.xlabel("Idade", labelpad=10,fontweight='bold')
plt.xticks(np.arange(0, 100, step=10),size=14)
plt.yticks(size=12)

new_labels = ['1','2','3']
for t, l in zip(g._legend.texts, new_labels): t.set_text(l)



plt.figure(figsize=(10,8))
sns.scatterplot(x="Age",
            y="IDH",
            hue='Clusters',
            data=result_B,
            s=200, 
            alpha=0.5,
            edgecolors = 'black',
            palette=sns.color_palette(['#f51720', '#189ab4','orange']))
plt.ylabel("Genótipos", labelpad=10,fontweight='bold')
plt.xlabel("Idade", labelpad=10,fontweight='bold')
plt.xticks(np.arange(0, 110, step=10),size=14)
plt.yticks(np.arange(0, 1.1, step=0.1),size=14)
plt.legend(fontsize=16,frameon=True, loc=(1,0.8), ncol=1, title="Clusters")

plt.figure(figsize=(10,8))
sns.scatterplot(x="Age",
            y="ASB",
            hue='Clusters',
            data=result_B,
            s=200, 
            alpha=0.5,
            edgecolors = 'black',
            palette=sns.color_palette(['#f51720', '#189ab4','orange']))
plt.ylabel("Genótipos", labelpad=10,fontweight='bold')
plt.xlabel("Idade", labelpad=10,fontweight='bold')
plt.xticks(np.arange(0, 110, step=10),size=14)
plt.yticks(np.arange(0, 1.1, step=0.1),size=14)
plt.legend(fontsize=16,frameon=True, loc=(1,0.8), ncol=1, title="Clusters")

plt.figure(figsize=(10,8))
sns.scatterplot(x="Age",
            y="GSPIB",
            hue='Clusters',
            data=result_B,
            s=200, 
            alpha=0.5,
            edgecolors = 'black',
            palette=sns.color_palette(['#f51720', '#189ab4','orange']))
plt.ylabel("Genótipos", labelpad=10,fontweight='bold')
plt.xlabel("Idade", labelpad=10,fontweight='bold')
plt.xticks(np.arange(0, 110, step=10),size=14)
plt.yticks(np.arange(0, 1.1, step=0.1),size=14)
plt.legend(fontsize=16,frameon=True, loc=(1,0.8), ncol=1, title="Clusters")

"""**Análise obtida com a amostra**


---

> **Cluster 0:**

*   Predominância do genótipo **Asiático**, com **66,67%** (28) dos casos no cluster, contra **33,33%** do **ECSA**.
* A faixa de idade do cluster é entre **48 e 88** anos.
* O gênero predominante é o Feminino, com **61,90%** dos casos.
* Característica deste grupo no que tange as variáveis socioeconômicas é o intervalo do IDH que é entre **0.56 e 0.92**, do ASB que é entre **0.34 e 1.0** e do GSPIB que é entre **0.03 e	0.17**.
* O país predominante neste cluster é os Estados Unidos, com um total de **66,67** (28) dos casos.

> **Cluster 1:**

*   Predominância do genótipo **ECSA**, com **54,12%** (46) dos casos no cluster, contra **55,88%** (39) do **Asiático**.
* A faixa de idade do cluster é entre **23 e 46** anos.
* O gênero predominante é o Feminino, com **54,12%** dos casos.
* Característica deste grupo no que tange as variáveis socioeconômicas possui praticamente o mesmo intervalo para as 3, tornando irrelevante estes valores para o clustering.
* O país predominante neste cluster é a Índia, com um total de **49,41%** (42) dos casos, seguido pelos Estados Unidos com **35,29%** (30)

> **Cluster 2:**

*   Predominância do genótipo **Asiático**, com **87,27%** (96) dos casos no cluster, contra **12,73%** (14) do **Asiático**.
* A faixa de idade do cluster é entre **1 e 21** anos.
* O gênero predominante é o Masculino, com **66,36%** dos casos (73).
* Característica deste grupo no que tange as variáveis socioeconômicas possui praticamente o mesmo intervalo para as 3, tornando irrelevante estes valores para o clustering.
* O país predominante neste cluster é Nicarágua com **80,91%** (89) dos casos.

**Avaliação Final**

---

> O fator determinante para o clustering desta amostra foi a idade dos pacientes infectados pelo vírus. Existe uma exclusividade entre o intervalo desta variável em cada um dos clusters, tornando possível realizar uma análise mais concreta diante dos resultados presentes.

> As pessoas com idade entre 1 e 21 anos, e 48 e 88 anos, tiveram em sua maioria, a infecção pelo genótipo Asiático, enquanto as do intervalo entre 23 e 46 anos com o genótipo ECSA. Porém, este último não foi tão predominante, tendo uma pouca diferença de 7 casos em comparação com o outro genótipo.

> Já referente ao gênero, de 23 a 88 anos (clusters 0 e 1), em sua maioria as mulheres foram afetadas pelo vírus Chikungunya. Ja para a menor faixa de idade, a predominância foi para os homens.

> Nenhuma das variáveis socioeconômicas apresentaram determinância nos resultados, nem exclusividade. Não foram influentes, nem para a geração dos clusters, nem para o levantamento dos resultados.

> Por fim, para a primeira faixa de idade, a maioria dos casos foram registrados na Nicarágua, enquanto na segunda faixa na Índia e na última nos Estados Unidos. Vale ressaltar que, na segunda faixa, os Estados Unidos apresentaram 35,29% dos casos, vindo logo após da Índia, se tornando o país que mais teve infectados com as pessoas a partir dos 23 anos.

# **Interpretação do agrupamento da Terceira Amostra**
"""

result_C = pd.read_csv('/content/resultados_C.csv',sep=',')
result_C

proto_labs = best_cluster_C_1000

cat_data = sample_C.copy()
for i in cat_data.select_dtypes(include='object'):
    cat_data[i] = cat_data[i].astype('category')


clf_kp = LGBMClassifier(colsample_by_tree=0.8)
cv_scores_kp = cross_val_score(clf_kp, cat_data, proto_labs, scoring='f1_weighted')
print(f'CV F1 score for K-Prototypes clusters is {np.mean(cv_scores_kp)}')

clf_kp.fit(cat_data, proto_labs)

explainer_kp = shap.TreeExplainer(clf_kp)
shap_values_kp = explainer_kp.shap_values(cat_data)

shap.summary_plot(shap_values_kp, cat_data, plot_type="bar", plot_size=(10, 6))

result_C['Segment'] = result_C['Clusters'].map({0:'First', 1:'Second', 2:'Third'})
result_C

result_C['Segment'] = result_C['Segment'].astype('category')
result_C['Segment'] = result_C['Segment'].cat.reorder_categories(['First','Second'])
result_C

analysis_C = result_C.copy()

analysis_C['IDH Min'] = result_C['IDH']
analysis_C['IDH Max'] = result_C['IDH']
analysis_C['ASB Min'] = result_C['ASB']
analysis_C['ASB Max'] = result_C['ASB']
analysis_C['GSPIB Min'] = result_C['GSPIB']
analysis_C['GSPIB Max'] = result_C['GSPIB']

analysis_C

# Cluster interpretation
analysis_C.rename(columns = {'Clusters':'Total','IDH':'IDH mean','ASB':'ASB mean','GSPIB':'GSPIB mean','Age':'Age mean'}, inplace = True)
analysis_C.groupby('Segment').agg(
    {
        'Total':'count',
        'Genotype': lambda x: x.value_counts().index[0],
        'Country': lambda x: x.value_counts().index[0],
        'Symptom': lambda x: x.value_counts().index[0],
        'IDH Min': 'min',
        'IDH Max': 'max',
        'IDH mean': 'mean',
        'ASB Min': 'min',
        'ASB Max': 'max',
        'ASB mean': 'mean',
        'GSPIB Min': 'min',
        'GSPIB Max': 'max',
        'GSPIB mean': 'mean'
    }
).reset_index()

g=sns.catplot(x="IDH",
            y="Symptom",
            hue='Clusters',
            data=result_C,
            s=10, 
            height=7,
            aspect=1.8,
            alpha=0.5,
            kind = 'strip',
            palette=sns.color_palette(['#f51720', '#189ab4']))
plt.ylabel("Sintomas", labelpad=10,fontweight='bold')
plt.xlabel("Índice de Desenvolvimento Humano (IDH)", labelpad=10,fontweight='bold')
plt.xticks(np.arange(0, 1.1, step=0.1),size=14)
plt.yticks(size=12)

new_labels = ['1','2','3']
for t, l in zip(g._legend.texts, new_labels): t.set_text(l)

sns.catplot(x="Genotype",
            y="Country",
            hue='Clusters',
            data=result_C,
            s=10, 
            height=7,
            aspect=2,
            alpha=0.5,
            kind = 'strip',
            palette=sns.color_palette(['#f51720', '#189ab4']))
plt.ylabel("Sintomas", labelpad=10,fontweight='bold')
plt.xlabel("Genótipos", labelpad=10,fontweight='bold')
plt.xticks(size=14)

plt.yticks(size=12)

sns.catplot(x="Symptom",
            y="Country",
            hue='Clusters',
            data=result_C,
            height=7,
            aspect=1.3,
            s=10, 
            alpha=0.5,
            kind = 'strip',
            palette=sns.color_palette(['#f51720', '#189ab4']))
plt.ylabel("Genótipos", labelpad=10,fontweight='bold')
plt.xlabel("Idade", labelpad=10,fontweight='bold')
plt.xticks(size=14)
plt.yticks(size=12)

sns.catplot(x="IDH",
            y="Genotype",
            hue='Clusters',
            data=result_C,
            s=10, 
            height=7,
            aspect=1.3,
            alpha=0.5,
            kind = 'strip',
            palette=sns.color_palette(['#f51720', '#189ab4','orange']))
plt.ylabel("Genótipos", labelpad=10,fontweight='bold')
plt.xlabel("IDH", labelpad=10,fontweight='bold')
plt.xticks(np.arange(0, 1.1, step=0.1),size=14)
plt.yticks(size=12)

sns.catplot(x="ASB",
            y="Genotype",
            hue='Clusters',
            data=result_C,
            s=10, 
            height=7,
            aspect=1.3,
            alpha=0.5,
            kind = 'strip',
            palette=sns.color_palette(['#f51720', '#189ab4','orange']))
plt.ylabel("Genótipos", labelpad=10,fontweight='bold')
plt.xlabel("ASB", labelpad=10,fontweight='bold')
plt.xticks(np.arange(0, 1.1, step=0.1),size=14)
plt.yticks(size=12)

sns.catplot(x="GSPIB",
            y="Genotype",
            hue='Clusters',
            data=result_C,
            s=10, 
            height=7,
            aspect=1.3,
            alpha=0.5,
            kind = 'strip',
            palette=sns.color_palette(['#f51720', '#189ab4','orange']))
plt.ylabel("Genótipos", labelpad=10,fontweight='bold')
plt.xlabel("GSPIB", labelpad=10,fontweight='bold')
plt.xticks(np.arange(0, 1.1, step=0.1),size=14)
plt.yticks(size=12)

"""**Avaliação Final**



---

> A amostra apresenta problemas devido a natureza dos seus dados que não permitiram fazer um levantamento preciso das informações, muito menos levantar as análises.

> A análise deveria ser em torno dos casos. Porém, cada caso é representado por várias linhas, devido a variedade dos sintomas. E isso foi muito ruim, pois o algoritmo separou linhas de um mesmo caso em grupos diferentes. Por exemplo, a contagem dos genótipos no cluster 0 não é possível ter uma eficácia referente a predominância, pois, para o mesmo caso, no cluster 1 também tem registros do mesmo genótipo.

> Devido a grande variação dos sintomas, nenhum padrão foi encontrado, de forma a contornar este problema. Como possíveis soluções, seria interessante criar categorias para as doenças, de forma a minimizar a sua variedade e tentar utilizar o algoritmo, de forma a ter melhores agrupamentos.

# **Interpretação do agrupamento da Quarta Amostra**
"""

result_D = pd.read_csv('/content/resultados_D.csv',sep=',')
result_D

proto_labs = best_cluster_D_1000

cat_data = sample_D.copy()
for i in cat_data.select_dtypes(include='object'):
    cat_data[i] = cat_data[i].astype('category')


clf_kp = LGBMClassifier(colsample_by_tree=0.8)
cv_scores_kp = cross_val_score(clf_kp, cat_data, proto_labs, scoring='f1_weighted')
print(f'CV F1 score for K-Prototypes clusters is {np.mean(cv_scores_kp)}')

clf_kp.fit(cat_data, proto_labs)

explainer_kp = shap.TreeExplainer(clf_kp)
shap_values_kp = explainer_kp.shap_values(cat_data)

shap.summary_plot(shap_values_kp, cat_data, plot_type="bar", plot_size=(10, 6))

result_D['Segment'] = result_D['Clusters'].map({0:'First', 1:'Second', 2:'Third'})
result_D

result_D['Segment'] = result_D['Segment'].astype('category')
result_D['Segment'] = result_D['Segment'].cat.reorder_categories(['First','Second','Third'])
result_D

analysis_D = result_D.copy()

analysis_D['IDH Min'] = result_D['IDH']
analysis_D['IDH Max'] = result_D['IDH']
analysis_D['ASB Min'] = result_D['ASB']
analysis_D['ASB Max'] = result_D['ASB']
analysis_D['GSPIB Min'] = result_D['GSPIB']
analysis_D['GSPIB Max'] = result_D['GSPIB']

analysis_D

# Cluster interpretation
analysis_D.rename(columns = {'Clusters':'Total','IDH':'IDH mean','ASB':'ASB mean','GSPIB':'GSPIB mean','Age':'Age mean'}, inplace = True)
analysis_D.groupby('Segment').agg(
    {
        'Total':'count',
        'Genotype': lambda x: x.value_counts().index[0],
        'Country': lambda x: x.value_counts().index[0],
        'Symptom': lambda x: x.value_counts().index[0],
        'IDH Min': 'min',
        'IDH Max': 'max',
        'IDH mean': 'mean',
        'ASB Min': 'min',
        'ASB Max': 'max',
        'ASB mean': 'mean',
        'GSPIB Min': 'min',
        'GSPIB Max': 'max',
        'GSPIB mean': 'mean'
    }
).reset_index()

g=sns.catplot(x="Genotype",
            y="Symptom",
            hue='Clusters',
            data=result_D,
            s=10, 
            height=7,
            aspect=2,
            alpha=0.5,
            kind = 'strip',
            palette=sns.color_palette(['#f51720', '#189ab4','orange']))
plt.ylabel("Sintomas", labelpad=10,fontweight='bold')
plt.xlabel("Genótipos", labelpad=10,fontweight='bold')
plt.xticks(size=14)
plt.yticks(size=12)

new_labels = ['1','2','3']
for t, l in zip(g._legend.texts, new_labels): t.set_text(l)

g = sns.catplot(x="IDH",
            y="Symptom",
            hue='Clusters',
            data=result_D,
            s=10, 
            height=7,
            aspect=2,
            alpha=0.5,
            kind = 'strip',
            palette=sns.color_palette(['#f51720', '#189ab4','orange']))
plt.ylabel("Sintomas", labelpad=10,fontweight='bold')
plt.xlabel("Índice de Desenvolvimento Humano (IDH)", labelpad=10,fontweight='bold')
plt.xticks(size=14)
plt.yticks(size=12)

plt.xticks(np.arange(0, 1.1, step=0.1),size=14)

new_labels = ['1','2','3']
for t, l in zip(g._legend.texts, new_labels): t.set_text(l)

g = sns.catplot(x="Country",
            y="Symptom",
            hue='Clusters',
            data=result_D,
            height=8,
            aspect=1.8,
            s=10, 
            alpha=0.5,
            kind = 'strip',
            palette=sns.color_palette(['#f51720', '#189ab4','orange']))
plt.ylabel("Sintomas", labelpad=10,fontweight='bold')
plt.xlabel("Países", labelpad=10,fontweight='bold')
plt.xticks(size=14,rotation=90)
plt.yticks(size=12)

new_labels = ['1','2','3']
for t, l in zip(g._legend.texts, new_labels): t.set_text(l)

sns.catplot(x="IDH",
            y="Genotype",
            hue='Clusters',
            data=result_D,
            s=10, 
            height=7,
            aspect=1.3,
            alpha=0.5,
            kind = 'strip',
            palette=sns.color_palette(['#f51720', '#189ab4','orange']))
plt.ylabel("Genótipos", labelpad=10,fontweight='bold')
plt.xlabel("IDH", labelpad=10,fontweight='bold')
plt.xticks(np.arange(0, 1.1, step=0.1),size=14)
plt.yticks(size=12)

sns.catplot(x="ASB",
            y="Genotype",
            hue='Clusters',
            data=result_D,
            s=10, 
            height=7,
            aspect=1.3,
            alpha=0.5,
            kind = 'strip',
            palette=sns.color_palette(['#f51720', '#189ab4','orange']))
plt.ylabel("Genótipos", labelpad=10,fontweight='bold')
plt.xlabel("ASB", labelpad=10,fontweight='bold')
plt.xticks(np.arange(0, 1.1, step=0.1),size=14)
plt.yticks(size=12)

sns.catplot(x="GSPIB",
            y="Genotype",
            hue='Clusters',
            data=result_D,
            s=10, 
            height=7,
            aspect=1.3,
            alpha=0.5,
            kind = 'strip',
            palette=sns.color_palette(['#f51720', '#189ab4','orange']))
plt.ylabel("Genótipos", labelpad=10,fontweight='bold')
plt.xlabel("GSPIB", labelpad=10,fontweight='bold')
plt.xticks(np.arange(0, 1.1, step=0.1),size=14)
plt.yticks(size=12)

"""**Avaliação Final**

---

> Semelhante à terceira amostra, nesta quarta o algoritmo também apresentou problemas relacionados ao mesmo caso estar em cluster diferentes. Porém, é interessante observar que ele tentou agrupar os dados baseados nos genótipos.

> Todos os dados com o genótipo Asiático foram colocados no cluster 1, enquanto Todos os dados com o genótipo Africano foram colocados no cluster 0, os do Asiático no cluster 1 e o do ECSA no cluster 2. Porém, o cluster 0 contém dados de todos os genótipos, e o cluster 1 contém dados do ECSA e do Asiático. Não houve uma exclusividade nos genótipos alocados.

> Mais uma vez, os dados socioeconômicos não surtiram nenhum efeito para a amostra. Nenhuma análise foi possível de ser realizada, tanto pela mistura das informações, quanto pelos valores dos sintomas.

#**Pode vir a ser útil...**
"""

# Verifique o custo do melhor cluster
#kprototype.cost_
# Verifique a iteração do melhor cluster
#kprototype.n_iter_ 
#Verifique os labels do melhor cluster
#kprototype.labels_
#Verificar os centróides
#kprototype.cluster_centroids_ 

#Adicionar melhor resultado
#result_A = sample_A
#result_A ['Cluster Labels'] = best_result_100
#result_A

#result_A_100 = pd.DataFrame() 
#result_A_100['Cost'].append(cost_A_100)
#result_A_100['Clusters'] = clusters_A_100
#np.save("centroids_A_100.txt", centroids)

#result_A_100.to_csv(r'/content/resultados_A_100.csv', index = False)

#def jaccardIndex_100(clusters, best_result):
#  print('ÍNDICE DE JACCARD') 
 # for item in range(len(clusters)):
  #  score = jaccard_score(best_result, clusters[item],average='weighted')
   # print('----------------------')
    #print('Cluster: {}'.format(item+1))
    #print("Índice de Jaccard: ", score)
    #jaccard_A_100.append(score)

#def f1Measure_100(clusters,best_result):
#  print('F1 MEASURE') 
 # for item in range(len(clusters)):
 #   score = f1_score(best_result, clusters[item],average='weighted')
 #   print('----------------------')
  #  print('Cluster: {}'.format(item+1))
 #   print("F-measure: ", score)
 #   f1_A_100.append(score)

 #percent_jaccard_A_100 = (metrics_A_100['Jaccard'].value_counts(normalize=True)
                #.mul(100)
               # .rename_axis('Jaccard index')
              #  .reset_index(name='Percentage'))

#percent_jaccard_A_100

ax = plt.subplots(figsize=(9, 5))
counts, bins, _ = plt.hist(df_idh['IDH'], bins=7,edgecolor='black')
plt.ylabel("Frequências")
plt.xlabel("IDH")
plt.rcParams.update({'font.size': 14})
plt.style.use("fivethirtyeight")
plt.xticks(np.arange(0, 1, step=0.1))
plt.yticks(np.arange(0, 800, step=100))


for n, b in zip(counts, bins):
        n = int(n)
        plt.gca().text(b+0.01, n + 35, str(n), color='black', fontweight='bold')

plt.show()